# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-04 20:34+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../dev/runtime.rst:21
msgid "TVM Runtime System"
msgstr ""

#: ../../dev/runtime.rst:23
msgid ""
"TVM supports multiple programming languages for the compiler stack "
"development and deployment. In this note, we explain the key elements of "
"the TVM runtime."
msgstr ""

#: ../../dev/runtime.rst:28
msgid "We need to satisfy quite a few interesting requirements:"
msgstr ""

#: ../../dev/runtime.rst:30
msgid ""
"Deployment: invoke the compiled function from python/javascript/c++ "
"language."
msgstr ""

#: ../../dev/runtime.rst:31
msgid "Debug: define a function in python and call that from a compiled function."
msgstr ""

#: ../../dev/runtime.rst:32
msgid ""
"Link: write driver code to call device specific code (CUDA) and call it "
"from compiled host function."
msgstr ""

#: ../../dev/runtime.rst:33
msgid "Prototype: define an IR pass from python and call that from C++ backend."
msgstr ""

#: ../../dev/runtime.rst:34
msgid "Expose: compiler stack developed in c++ to front-end (i.e, python)"
msgstr ""

#: ../../dev/runtime.rst:35
msgid ""
"Experiment: ship a compiled function to an embedded device to directly "
"run there."
msgstr ""

#: ../../dev/runtime.rst:37
msgid ""
"We want to be able to define a function from any language and call from "
"another. We also want the runtime core to be minimal to deploy to "
"embedded devices."
msgstr ""

#: ../../dev/runtime.rst:43
msgid "PackedFunc"
msgstr ""

#: ../../dev/runtime.rst:45
msgid ""
"`PackedFunc`_ is a simple but elegant solution we find to solve the "
"challenges listed. The following code block provides an example in C++"
msgstr ""

#: ../../dev/runtime.rst:68
msgid ""
"In the above codeblock, we defined a PackedFunc MyAdd. It takes two "
"arguments : ``args`` represents input arguments and ``rv`` represents "
"return value. The function is type-erased, which means that the function "
"signature does not restrict which input type to pass in or type to "
"return. Under the hood, when we call a PackedFunc, it packs the input "
"arguments to TVMArgs on stack, and gets the result back via TVMRetValue."
msgstr ""

#: ../../dev/runtime.rst:74
msgid ""
"Thanks to template tricks in C++, we can call a PackedFunc just like a "
"normal function. Because of its type-erased nature, we can call a "
"PackedFunc from dynamic languages like python, without additional glue "
"code for each new type function created. The following example registers "
"PackedFunc in C++ and calls from python."
msgstr ""

#: ../../dev/runtime.rst:91
msgid ""
"Most of the magic of PackedFunc lies in ``TVMArgs`` and ``TVMRetValue`` "
"structure. We restrict a list of possible types which can be passed. Here"
" are the common ones:"
msgstr ""

#: ../../dev/runtime.rst:95
msgid "int, float and string"
msgstr ""

#: ../../dev/runtime.rst:96
msgid "PackedFunc itself"
msgstr ""

#: ../../dev/runtime.rst:97
msgid "Module for compiled modules"
msgstr ""

#: ../../dev/runtime.rst:98
msgid "DLTensor* for tensor object exchange"
msgstr ""

#: ../../dev/runtime.rst:99
msgid "TVM Object to represent any object in IR"
msgstr ""

#: ../../dev/runtime.rst:101
msgid ""
"The restriction makes the implementation simple without the need of "
"serialization. Despite being minimum, the PackedFunc is sufficient for "
"the use-case of deep learning deployment as most functions only take "
"DLTensor or numbers."
msgstr ""

#: ../../dev/runtime.rst:105
msgid ""
"Since one PackedFunc can take another PackedFunc as an argument, we can "
"pass functions from python (as PackedFunc) to C++."
msgstr ""

#: ../../dev/runtime.rst:129
msgid ""
"TVM provides a `minimum C API`_, which allows us to embed the PackedFunc "
"into any languages. Besides python, so far we supported `java`_ and "
"`javascript`_. This philosophy of embedded API is very like Lua, except "
"that we don't have a new language but use C++."
msgstr ""

#: ../../dev/runtime.rst:139
msgid ""
"One fun fact about PackedFunc is that we use it for both compiler and "
"deployment stack."
msgstr ""

#: ../../dev/runtime.rst:141
msgid ""
"All TVM's compiler pass functions are exposed to frontend as PackedFunc, "
"see `here`_"
msgstr ""

#: ../../dev/runtime.rst:142
msgid "The compiled module also returns the compiled function as PackedFunc"
msgstr ""

#: ../../dev/runtime.rst:146
msgid ""
"To keep the runtime minimum, we isolated the IR Object support from the "
"deployment runtime. The resulting runtime takes around 200K - 600K "
"depending on how many runtime driver modules (e.g., CUDA) get included."
msgstr ""

#: ../../dev/runtime.rst:148
msgid ""
"The overhead of calling into PackedFunc vs. a normal function is small, "
"as it is only saving a few values on the stack. So it is OK as long as we"
" don't wrap small functions. In summary, the PackedFunc is the universal "
"glue in TVM where we use it extensively to support our compiler and "
"deployment."
msgstr ""

#: ../../dev/runtime.rst:153
msgid "Module"
msgstr ""

#: ../../dev/runtime.rst:155
msgid ""
"Since TVM supports multiple types of devices, we need to support "
"different type of drivers. We have to use the driver API to load the "
"kernel, set up the argument in packed format and perform kernel launch. "
"We also need to patch up the driver API so that the exposed functions are"
" threadsafe. So we often need to implement these driver glues in C++ and "
"expose them to the user. We can certainly not do it for each type of "
"functions, so again PackedFunc is our answer."
msgstr ""

#: ../../dev/runtime.rst:161
msgid ""
"TVM defines the compiled object as `Module`_. The user can get the "
"compiled function from Module as PackedFunc. The generated compiled code "
"can dynamically get function from Module in runtime. It caches the "
"function handle in the first call and reuses in subsequent calls. We use "
"this to link device code and callback into any PackedFunc(e.g., python) "
"from generated code."
msgstr ""

#: ../../dev/runtime.rst:167
msgid ""
"The ModuleNode is an abstract class that can be implemented by each type "
"of device. So far we support modules for CUDA, Metal, OpenCL and loading "
"dynamic shared libraries. This abstraction makes introduction of new "
"device easy, and we do not need to redo the host code generation for each"
" type of device."
msgstr ""

#: ../../dev/runtime.rst:172
msgid "Remote Deployment"
msgstr ""

#: ../../dev/runtime.rst:174
msgid ""
"The PackedFunc and Module system also makes it easy to ship the function "
"into remote devices directly. Under the hood, we have an RPCModule that "
"serializes the arguments to do the data movement and launches the "
"computation on the remote."
msgstr ""

#: ../../dev/runtime.rst:179
msgid ""
"The RPC server itself is minimum and can be bundled into the runtime. We "
"can start a minimum TVM RPC server on iPhone/android/raspberry pi or even"
" the browser. The cross compilation on server and shipping of the module "
"for testing can be done in the same script. Checkout :ref:`tutorial-"
"cross-compilation-and-rpc` for more details."
msgstr ""

#: ../../dev/runtime.rst:184
msgid ""
"This instant feedback gives us a lot of advantages. For example, to test "
"the correctness of generated code on iPhone, we no longer have to write "
"test-cases in swift/objective-c from scratch -- We can use RPC to execute"
" on iPhone, copy the result back and do verification on the host via "
"numpy. We can also do the profiling using the same script."
msgstr ""

#: ../../dev/runtime.rst:187
msgid "TVM Object and Compiler Stack"
msgstr ""

#: ../../dev/runtime.rst:189
msgid ""
"As we mentioned earlier, we build compiler stack API on top of the "
"PackedFunc runtime system. We faced a constant changing of the compiler "
"API for the need of research. We need a new language object or IR node "
"whenever we want to test out new primitives. However, we don't want to "
"change our API from time to time. Besides that, we also want to"
msgstr ""

#: ../../dev/runtime.rst:193
msgid "be able to serialize any language object and IRs"
msgstr ""

#: ../../dev/runtime.rst:194
msgid ""
"be able to explore, print, and manipulate the IR objects in front-end "
"language to do quick prototyping."
msgstr ""

#: ../../dev/runtime.rst:196
msgid ""
"We introduced a base class, called `Object`_ to solve this problem. All "
"the language object in the compiler stack is a subclass of ``Object``. "
"Each object contains a string type_key that uniquely identifies the type "
"of object. We choose string instead of int as type key so new ``Object`` "
"class can be added in the decentralized fashion without adding the code "
"back to the central repo. To ease the speed of dispatching, we allocate "
"an integer type_index at runtime for each type_key."
msgstr ""

#: ../../dev/runtime.rst:203
msgid ""
"Since usually one ``Object`` could be referenced in multiple places in "
"the language, we use a shared_ptr to keep track of reference. We use "
"``ObjectRef`` class to represent a reference to the ``Object``. We can "
"roughly view ``ObjectRef`` class as shared_ptr to the ``Object`` "
"container. We can also define subclass ``ObjectRef`` to hold each "
"subtypes of ``Object``. Each subclass of ``Object`` needs to define the "
"VisitAttr function."
msgstr ""

#: ../../dev/runtime.rst:230
msgid ""
"Each ``Object`` subclass will override this to visit its members. Here is"
" an example implementation of TensorNode."
msgstr ""

#: ../../dev/runtime.rst:255
msgid ""
"In the above examples, both ``Operation`` and ``Array<Expr>`` are "
"ObjectRef. The VisitAttrs gives us a reflection API to visit each member "
"of the object. We can use this function to visit the node and serialize "
"any language object recursively. It also allows us to get members of an "
"object easily in front-end language. For example, in the following code, "
"we accessed the op field of the TensorNode."
msgstr ""

#: ../../dev/runtime.rst:270
msgid ""
"New ``Object`` can be added to C++ without changing the front-end "
"runtime, making it easy to make extensions to the compiler stack. Note "
"that this is not the fastest way to expose members to front-end language,"
" but might be one of the simplest approaches possible. We also find that "
"it fits our purposes as we mainly use python for testing and prototyping "
"and still use c++ to do the heavy lifting job."
msgstr ""

#: ../../dev/runtime.rst:276
msgid "Implementation Details"
msgstr ""

#: ../../dev/runtime.rst:278
msgid ""
"Each argument in PackedFunc contains a union value `TVMValue`_ and a type"
" code. This design allows the dynamically typed language to convert to "
"the corresponding type directly, and statically typed language to do "
"runtime type checking during conversion."
msgstr ""

#: ../../dev/runtime.rst:284
msgid "The relevant files are"
msgstr ""

#: ../../dev/runtime.rst:286
msgid "`packed_func.h`_ for C++ API"
msgstr ""

#: ../../dev/runtime.rst:287
msgid "`c_runtime_api.cc`_ for C API and how to provide callback."
msgstr ""

#: ../../dev/runtime.rst:292
msgid ""
"To support extension types, we used a registry system to register type "
"related information, like support of any in C++, see `Extension types`_ "
"for more details."
msgstr ""

