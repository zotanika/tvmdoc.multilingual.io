# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020 - 2021, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-06 10:20+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../_staging/reference/api/python/tir.rst:21
msgid "tvm.tir"
msgstr ""

#: of tvm.tir:1
msgid "Namespace for Tensor-level IR"
msgstr ""

#: of tvm.tir:1 tvm.tir.analysis:1 tvm.tir.transform:1
msgid "**Classes:**"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Buffer <tvm.tir.Buffer>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1 tvm.tir.buffer.Buffer:1
#: tvm.tir:1:<autosummary>:1
msgid "Symbolic data buffer in TVM."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`DataProducer <tvm.tir.DataProducer>`\\ \\(\\)"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Layout <tvm.tir.Layout>`\\ \\(\\)"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
"Layout is composed of upper cases, lower cases and numbers, where upper "
"case indicates a primal axis and the corresponding lower case with factor"
" size indicates the subordinate axis."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`BijectiveLayout <tvm.tir.BijectiveLayout>`\\ \\(\\)"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid "Bijective mapping for two layouts (src-layout and dst-layout)."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Var <tvm.tir.Var>`\\ \\(name\\, dtype\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1 tvm.tir.expr.Var:1
#: tvm.tir:1:<autosummary>:1
msgid "Symbolic variable."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`SizeVar <tvm.tir.SizeVar>`\\ \\(name\\, dtype\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.SizeVar:2 tvm.tir:1:<autosummary>:1
msgid "Symbolic variable to represent a tensor index size"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Reduce <tvm.tir.Reduce>`\\ \\(combiner\\, src\\, rdom\\, "
"condition\\, ...\\)"
msgstr ""

#: of tvm.tir.expr.Reduce:1 tvm.tir:1:<autosummary>:1
msgid "Reduce node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`FloatImm <tvm.tir.FloatImm>`\\ \\(dtype\\, value\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.FloatImm:1 tvm.tir:1:<autosummary>:1
msgid "Float constant."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`IntImm <tvm.tir.IntImm>`\\ \\(dtype\\, value\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.IntImm:1 tvm.tir:1:<autosummary>:1
msgid "Int constant."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`StringImm <tvm.tir.StringImm>`\\ \\(value\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.StringImm:1 tvm.tir:1:<autosummary>:1
msgid "String constant."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Cast <tvm.tir.Cast>`\\ \\(dtype\\, value\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Cast:1 tvm.tir:1:<autosummary>:1
msgid "Cast expression."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Add <tvm.tir.Add>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Add:1 tvm.tir:1:<autosummary>:1
msgid "Add node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Sub <tvm.tir.Sub>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Sub:1 tvm.tir:1:<autosummary>:1
msgid "Sub node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Mul <tvm.tir.Mul>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Mul:1 tvm.tir:1:<autosummary>:1
msgid "Mul node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Div <tvm.tir.Div>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Div:1 tvm.tir:1:<autosummary>:1
msgid "Div node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Mod <tvm.tir.Mod>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Mod:1 tvm.tir:1:<autosummary>:1
msgid "Mod node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`FloorDiv <tvm.tir.FloorDiv>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.FloorDiv:1 tvm.tir:1:<autosummary>:1
msgid "FloorDiv node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`FloorMod <tvm.tir.FloorMod>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.FloorMod:1 tvm.tir:1:<autosummary>:1
msgid "FloorMod node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Min <tvm.tir.Min>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Min:1 tvm.tir:1:<autosummary>:1
msgid "Min node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Max <tvm.tir.Max>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Max:1 tvm.tir:1:<autosummary>:1
msgid "Max node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`EQ <tvm.tir.EQ>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.EQ:1 tvm.tir:1:<autosummary>:1
msgid "EQ node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`NE <tvm.tir.NE>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.NE:1 tvm.tir:1:<autosummary>:1
msgid "NE node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`LT <tvm.tir.LT>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.LT:1 tvm.tir:1:<autosummary>:1
msgid "LT node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`LE <tvm.tir.LE>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.LE:1 tvm.tir:1:<autosummary>:1
msgid "LE node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`GT <tvm.tir.GT>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.GT:1 tvm.tir:1:<autosummary>:1
msgid "GT node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`GE <tvm.tir.GE>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.GE:1 tvm.tir:1:<autosummary>:1
msgid "GE node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`And <tvm.tir.And>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.And:1 tvm.tir:1:<autosummary>:1
msgid "And node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Or <tvm.tir.Or>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Or:1 tvm.tir:1:<autosummary>:1
msgid "Or node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Not <tvm.tir.Not>`\\ \\(a\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Not:1 tvm.tir:1:<autosummary>:1
msgid "Not node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Select <tvm.tir.Select>`\\ \\(condition\\, true\\_value\\, "
"false\\_value\\[\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.expr.Select:1 tvm.tir:1:<autosummary>:1
msgid "Select node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`BufferLoad <tvm.tir.BufferLoad>`\\ \\(buffer\\, indices\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.expr.BufferLoad:1 tvm.tir:1:<autosummary>:1
msgid "Buffer load node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`ProducerLoad <tvm.tir.ProducerLoad>`\\ \\(producer\\, "
"indices\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.ProducerLoad:1 tvm.tir:1:<autosummary>:1
msgid "Producer load node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Load <tvm.tir.Load>`\\ \\(dtype\\, buffer\\_var\\, index\\[\\, "
"predicate\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Load:1 tvm.tir:1:<autosummary>:1
msgid "Load node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Ramp <tvm.tir.Ramp>`\\ \\(base\\, stride\\, lanes\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Ramp:1 tvm.tir:1:<autosummary>:1
msgid "Ramp node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Broadcast <tvm.tir.Broadcast>`\\ \\(value\\, lanes\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Broadcast:1 tvm.tir:1:<autosummary>:1
msgid "Broadcast node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Shuffle <tvm.tir.Shuffle>`\\ \\(vectors\\, indices\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Shuffle:1 tvm.tir:1:<autosummary>:1
msgid "Shuffle node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Call <tvm.tir.Call>`\\ \\(dtype\\, op\\, args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Call:1 tvm.tir:1:<autosummary>:1
msgid "Call node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`CallEffectKind <tvm.tir.CallEffectKind>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.expr.CallEffectKind:1 tvm.tir:1:<autosummary>:1
msgid "Possible kinds of Call effects."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Let <tvm.tir.Let>`\\ \\(var\\, value\\, body\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Let:1 tvm.tir:1:<autosummary>:1
msgid "Let node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`IterVar <tvm.tir.IterVar>`\\ \\(dom\\, var\\, iter\\_type\\[\\, "
"thread\\_tag\\, span\\]\\)"
msgstr ""

#: of tvm.tir.expr.IterVar:1 tvm.tir:1:<autosummary>:1
msgid "Represent iteration variable."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`CommReducer <tvm.tir.CommReducer>`\\ \\(lhs\\, rhs\\, result\\, "
"identity\\_element\\)"
msgstr ""

#: of tvm.tir.expr.CommReducer:1 tvm.tir:1:<autosummary>:1
msgid "Commutative reduce operator"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Any <tvm.tir.Any>`\\ \\(\\[span\\]\\)"
msgstr ""

#: of tvm.tir.expr.Any:1 tvm.tir:1:<autosummary>:1
msgid "Any node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Stmt <tvm.tir.Stmt>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1 tvm.tir.stmt.Stmt:1
#: tvm.tir:1:<autosummary>:1
msgid "Base class of all the statements."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`LetStmt <tvm.tir.LetStmt>`\\ \\(var\\, value\\, body\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.LetStmt:1 tvm.tir:1:<autosummary>:1
msgid "LetStmt node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`AssertStmt <tvm.tir.AssertStmt>`\\ \\(condition\\, message\\, "
"body\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.AssertStmt:1 tvm.tir:1:<autosummary>:1
msgid "AssertStmt node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`ForKind <tvm.tir.ForKind>`\\ \\(value\\)"
msgstr ""

#: of tvm.tir.stmt.ForKind:1 tvm.tir:1:<autosummary>:1
msgid "The kind of the for loop."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`For <tvm.tir.For>`\\ \\(loop\\_var\\, min\\_val\\, extent\\, "
"kind\\, body\\[\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.stmt.For:1 tvm.tir:1:<autosummary>:1
msgid "For node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`While <tvm.tir.While>`\\ \\(condition\\, body\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.While:1 tvm.tir:1:<autosummary>:1
msgid "While node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`BufferStore <tvm.tir.BufferStore>`\\ \\(buffer\\, value\\, "
"indices\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.BufferStore:1 tvm.tir:1:<autosummary>:1
msgid "Buffer store node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`BufferRealize <tvm.tir.BufferRealize>`\\ \\(buffer\\, bounds\\, "
"condition\\, body\\)"
msgstr ""

#: of tvm.tir.stmt.BufferRealize:1 tvm.tir:1:<autosummary>:1
msgid "Buffer realize node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Store <tvm.tir.Store>`\\ \\(buffer\\_var\\, value\\, index\\[\\,"
" predicate\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.stmt.Store:1 tvm.tir:1:<autosummary>:1
msgid "Store node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`ProducerStore <tvm.tir.ProducerStore>`\\ \\(producer\\, value\\,"
" indices\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.ProducerStore:1 tvm.tir:1:<autosummary>:1
msgid "ProducerStore node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Allocate <tvm.tir.Allocate>`\\ \\(buffer\\_var\\, dtype\\, "
"extents\\, ...\\[\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.stmt.Allocate:1 tvm.tir:1:<autosummary>:1
msgid "Allocate node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`AttrStmt <tvm.tir.AttrStmt>`\\ \\(node\\, attr\\_key\\, value\\,"
" body\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.AttrStmt:1 tvm.tir:1:<autosummary>:1
msgid "AttrStmt node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`ProducerRealize <tvm.tir.ProducerRealize>`\\ \\(producer\\, "
"bounds\\, condition\\, ...\\)"
msgstr ""

#: of tvm.tir.stmt.ProducerRealize:1 tvm.tir:1:<autosummary>:1
msgid "ProducerRealize node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`SeqStmt <tvm.tir.SeqStmt>`\\ \\(seq\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.SeqStmt:1 tvm.tir:1:<autosummary>:1
msgid "Sequence of statements."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`IfThenElse <tvm.tir.IfThenElse>`\\ \\(condition\\, "
"then\\_case\\, else\\_case\\)"
msgstr ""

#: of tvm.tir.stmt.IfThenElse:1 tvm.tir:1:<autosummary>:1
msgid "IfThenElse node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`Evaluate <tvm.tir.Evaluate>`\\ \\(value\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.Evaluate:1 tvm.tir:1:<autosummary>:1
msgid "Evaluate node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Prefetch <tvm.tir.Prefetch>`\\ \\(buffer\\, bounds\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.Prefetch:1 tvm.tir:1:<autosummary>:1
msgid "Prefetch node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`BufferRegion <tvm.tir.BufferRegion>`\\ \\(buffer\\, region\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1 tvm.tir.stmt.BufferRegion:1
#: tvm.tir:1:<autosummary>:1
msgid "BufferRegion node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`MatchBufferRegion <tvm.tir.MatchBufferRegion>`\\ \\(buffer\\, "
"source\\)"
msgstr ""

#: of tvm.tir.stmt.MatchBufferRegion:1 tvm.tir:1:<autosummary>:1
msgid "MatchBufferRegion node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Block <tvm.tir.Block>`\\ \\(iter\\_vars\\, reads\\, writes\\, "
"name\\_hint\\, body\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1 tvm.tir.stmt.Block:1
#: tvm.tir:1:<autosummary>:1
msgid "Block node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`BlockRealize <tvm.tir.BlockRealize>`\\ \\(iter\\_values\\, "
"predicate\\, block\\)"
msgstr ""

#: of tvm.tir.stmt.BlockRealize:1 tvm.tir:1:<autosummary>:1
msgid "BlockRealize node."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`PrimFunc <tvm.tir.PrimFunc>`\\ \\(params\\, body\\[\\, "
"ret\\_type\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1 tvm.tir.function.PrimFunc:1
#: tvm.tir:1:<autosummary>:1
msgid "A function declaration expression."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`StmtSRef <tvm.tir.StmtSRef>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.schedule.block_scope.StmtSRef:1 tvm.tir:1:<autosummary>:1
msgid ""
"An object that refers to schedulable elements in the TensorIR, aka "
"\"sref\"."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`BlockScope <tvm.tir.BlockScope>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope:1 tvm.tir:1:<autosummary>:1
msgid ""
"An object corresponds to each block sref in the sref tree, which tracks "
"the producer-consumer dependency between blocks."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`ScheduleState <tvm.tir.ScheduleState>`\\ \\(mod\\, \\*\\[\\, "
"debug\\_mask\\]\\)"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState:1 tvm.tir:1:<autosummary>:1
msgid ""
"The state of scheduling, which exposes a `Replace` method as the primary "
"resort for all the scheduling primitives to manipulate the TensorIR."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`Schedule <tvm.tir.Schedule>`\\ \\(mod\\, \\*\\[\\, seed\\, "
"debug\\_mask\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule:1 tvm.tir:1:<autosummary>:1
msgid "The user-facing schedule class"
msgstr ""

#: of tvm.tir:1 tvm.tir.analysis:1 tvm.tir.stmt_functor:1 tvm.tir.transform:1
msgid "**Functions:**"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`decl_buffer <tvm.tir.decl_buffer>`\\ \\(shape\\[\\, dtype\\, "
"name\\, data\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.buffer.decl_buffer:1 tvm.tir:1:<autosummary>:1
msgid "Declare a new symbolic buffer."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`bijective_layout <tvm.tir.bijective_layout>`\\ "
"\\(src\\_layout\\, dst\\_layout\\)"
msgstr ""

#: of tvm.tir.data_layout.bijective_layout:1 tvm.tir:1:<autosummary>:1
msgid "Create a bijective layout mapping."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`layout <tvm.tir.layout>`\\ \\(layout\\_str\\)"
msgstr ""

#: of tvm.tir.data_layout.layout:1 tvm.tir:1:<autosummary>:1
msgid "Create a layout node from a string."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`stmt_seq <tvm.tir.stmt_seq>`\\ \\(\\*args\\)"
msgstr ""

#: of tvm.tir.stmt.stmt_seq:1 tvm.tir:1:<autosummary>:1
msgid "Make sequence of statements"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`stmt_list <tvm.tir.stmt_list>`\\ \\(stmt\\)"
msgstr ""

#: of tvm.tir.stmt.stmt_list:1 tvm.tir:1:<autosummary>:1
msgid "Make list of stmt from blocks."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`call_packed <tvm.tir.call_packed>`\\ \\(\\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.call_packed:1 tvm.tir:1:<autosummary>:1
msgid "Build expression by call an external packed function."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`call_intrin <tvm.tir.call_intrin>`\\ \\(dtype\\, func\\_name\\, "
"\\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.call_intrin:1 tvm.tir:1:<autosummary>:1
msgid "Build expression by calling an intrinsic function."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`call_pure_extern <tvm.tir.call_pure_extern>`\\ \\(dtype\\, "
"func\\_name\\, \\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.call_pure_extern:1 tvm.tir:1:<autosummary>:1
msgid "Build expression by calling a pure extern function."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`call_extern <tvm.tir.call_extern>`\\ \\(dtype\\, func\\_name\\, "
"\\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.call_extern:1 tvm.tir:1:<autosummary>:1
msgid "Build expression by calling a extern function."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`call_llvm_intrin <tvm.tir.call_llvm_intrin>`\\ \\(dtype\\, "
"name\\, \\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.call_llvm_intrin:1 tvm.tir:1:<autosummary>:1
msgid "Build expression by calling a llvm intrinsic function"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`call_llvm_pure_intrin <tvm.tir.call_llvm_pure_intrin>`\\ "
"\\(dtype\\, name\\, \\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.call_llvm_pure_intrin:1 tvm.tir:1:<autosummary>:1
msgid "Build expression by calling a pure llvm intrinsic function"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`ret <tvm.tir.ret>`\\ \\(val\\)"
msgstr ""

#: of tvm.tir.op.ret:1 tvm.tir:1:<autosummary>:1
msgid "Create a tir return expression"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`all <tvm.tir.all>`\\ \\(\\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.all:2 tvm.tir:1:<autosummary>:1
msgid "Create a new expression of the intersection of all conditions in the"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`any <tvm.tir.any>`\\ \\(\\*args\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.any:1 tvm.tir:1:<autosummary>:1
msgid "Create a new experssion of the union of all conditions in the arguments"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`min_value <tvm.tir.min_value>`\\ \\(dtype\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.min_value:1 tvm.tir:1:<autosummary>:1
msgid "minimum value of dtype"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`max_value <tvm.tir.max_value>`\\ \\(dtype\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.max_value:1 tvm.tir:1:<autosummary>:1
msgid "maximum value of dtype"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`trace <tvm.tir.trace>`\\ \\(args\\[\\, trace\\_action\\]\\)"
msgstr ""

#: of tvm.tir.op.trace:1 tvm.tir:1:<autosummary>:1
msgid "Trace tensor data at the runtime."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`exp <tvm.tir.exp>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.exp:1 tvm.tir:1:<autosummary>:1
msgid "Take exponential of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`exp2 <tvm.tir.exp2>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.exp2:1 tvm.tir:1:<autosummary>:1
msgid "Calculate 2**x"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`exp10 <tvm.tir.exp10>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.exp10:1 tvm.tir:1:<autosummary>:1
msgid "Calculate 10**x"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`log <tvm.tir.log>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.log:1 tvm.tir:1:<autosummary>:1
msgid "Take log of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`log2 <tvm.tir.log2>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.log2:1 tvm.tir:1:<autosummary>:1
msgid "Take log2 of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`log10 <tvm.tir.log10>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.log10:1 tvm.tir:1:<autosummary>:1
msgid "Take log10 of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`log1p <tvm.tir.log1p>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.log1p:1 tvm.tir:1:<autosummary>:1
msgid "Take log(x + 1) with respect to input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`ldexp <tvm.tir.ldexp>`\\ \\(x1\\, x2\\)"
msgstr ""

#: of tvm.tir.op.ldexp:1 tvm.tir:1:<autosummary>:1
msgid "Returns x1 * (2 ** x2)."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`clz <tvm.tir.clz>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.clz:1 tvm.tir:1:<autosummary>:1
msgid "Count leading zero bits of an integer x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`sin <tvm.tir.sin>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.sin:1 tvm.tir:1:<autosummary>:1
msgid "Take sin of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`sinh <tvm.tir.sinh>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.sinh:1 tvm.tir:1:<autosummary>:1
msgid "Take sinh of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`asin <tvm.tir.asin>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.asin:1 tvm.tir:1:<autosummary>:1
msgid "Take asin of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`asinh <tvm.tir.asinh>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.asinh:1 tvm.tir:1:<autosummary>:1
msgid "Take asinh of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`cos <tvm.tir.cos>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.cos:1 tvm.tir:1:<autosummary>:1
msgid "Take cos of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`cosh <tvm.tir.cosh>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.cosh:1 tvm.tir:1:<autosummary>:1
msgid "Take cosh of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`acos <tvm.tir.acos>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.acos:1 tvm.tir.op.acosh:1 tvm.tir:1:<autosummary>:1
msgid "Take acos of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`acosh <tvm.tir.acosh>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`tan <tvm.tir.tan>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.tan:1 tvm.tir:1:<autosummary>:1
msgid "Take tan of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`tanh <tvm.tir.tanh>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.tanh:1 tvm.tir:1:<autosummary>:1
msgid "Take hyperbolic tanh of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`atan <tvm.tir.atan>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.atan:1 tvm.tir:1:<autosummary>:1
msgid "Take atan of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`atan2 <tvm.tir.atan2>`\\ \\(x1\\, x2\\)"
msgstr ""

#: of tvm.tir.op.atan2:1 tvm.tir:1:<autosummary>:1
msgid "Take arctan2(x1, x2)."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`atanh <tvm.tir.atanh>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.atanh:1 tvm.tir:1:<autosummary>:1
msgid "Take atanh of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`erf <tvm.tir.erf>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.erf:1 tvm.tir:1:<autosummary>:1
msgid "Take gauss error function of the input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`sigmoid <tvm.tir.sigmoid>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.sigmoid:1 tvm.tir:1:<autosummary>:1
msgid "Quick function to get sigmoid"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`sqrt <tvm.tir.sqrt>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.sqrt:1 tvm.tir:1:<autosummary>:1
msgid "Take square root of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`rsqrt <tvm.tir.rsqrt>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.rsqrt:1 tvm.tir:1:<autosummary>:1
msgid "Take reciprocal of square root of input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`floor <tvm.tir.floor>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.floor:1 tvm.tir:1:<autosummary>:1
msgid "Take floor of float input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`ceil <tvm.tir.ceil>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.ceil:1 tvm.tir:1:<autosummary>:1
msgid "Take ceil of float input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`hypot <tvm.tir.hypot>`\\ \\(x1\\, x2\\)"
msgstr ""

#: of tvm.tir.op.hypot:1 tvm.tir:1:<autosummary>:1
msgid "Equivalent to sqrt(x1**2 + x2**2), element-wise."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`trunc <tvm.tir.trunc>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.trunc:1 tvm.tir:1:<autosummary>:1
msgid "Get truncated value of the input."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`abs <tvm.tir.abs>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.abs:1 tvm.tir:1:<autosummary>:1
msgid "Get absolute value of the input element-wise."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`round <tvm.tir.round>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.round:1 tvm.tir:1:<autosummary>:1
msgid "Round elements of the array to the nearest integer."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`nextafter <tvm.tir.nextafter>`\\ \\(x1\\, x2\\)"
msgstr ""

#: of tvm.tir.op.nextafter:1 tvm.tir:1:<autosummary>:1
msgid "Return the next floating-point value after x1 towards x2."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`nearbyint <tvm.tir.nearbyint>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`power <tvm.tir.power>`\\ \\(x\\, y\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.power:1 tvm.tir:1:<autosummary>:1
msgid "x power y"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`popcount <tvm.tir.popcount>`\\ \\(x\\)"
msgstr ""

#: of tvm.tir.op.popcount:1 tvm.tir:1:<autosummary>:1
msgid "Count the number of set bits in input x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`fmod <tvm.tir.fmod>`\\ \\(x\\, y\\)"
msgstr ""

#: of tvm.tir.op.fmod:1 tvm.tir:1:<autosummary>:1
msgid "Return the remainder of x divided by y with the same sign as x."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`if_then_else <tvm.tir.if_then_else>`\\ \\(cond\\, t\\, f\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.op.if_then_else:1 tvm.tir:1:<autosummary>:1
msgid "Conditional selection expression."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`isnan <tvm.tir.isnan>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.isnan:1 tvm.tir:1:<autosummary>:1
msgid "Check if input value is Nan."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`isfinite <tvm.tir.isfinite>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.isfinite:1 tvm.tir:1:<autosummary>:1
msgid "Check if input value is finite."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`isinf <tvm.tir.isinf>`\\ \\(x\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.isinf:1 tvm.tir:1:<autosummary>:1
msgid "Check if input value is infinite."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`copysign <tvm.tir.copysign>`\\ \\(x1\\, x2\\)"
msgstr ""

#: of tvm.tir.op.copysign:1 tvm.tir:1:<autosummary>:1
msgid "Change the sign of x1 to that of x2, element-wise."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`div <tvm.tir.div>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.div:1 tvm.tir:1:<autosummary>:1
msgid "Compute a / b as in C/C++ semantics."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`indexdiv <tvm.tir.indexdiv>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.indexdiv:1 tvm.tir:1:<autosummary>:1
msgid "Compute floor(a / b) where a and b are non-negative."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`indexmod <tvm.tir.indexmod>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid "Compute the remainder of indexdiv."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`truncdiv <tvm.tir.truncdiv>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.truncdiv:1 tvm.tir:1:<autosummary>:1
msgid "Compute the truncdiv of two expressions."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`truncmod <tvm.tir.truncmod>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.truncmod:1 tvm.tir:1:<autosummary>:1
msgid "Compute the truncmod of two expressions."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`floordiv <tvm.tir.floordiv>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.floordiv:1 tvm.tir:1:<autosummary>:1
msgid "Compute the floordiv of two expressions."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`floormod <tvm.tir.floormod>`\\ \\(a\\, b\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.op.floormod:1 tvm.tir:1:<autosummary>:1
msgid "Compute the floormod of two expressions."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`comm_reducer <tvm.tir.comm_reducer>`\\ \\(fcombine\\, "
"fidentity\\[\\, name\\]\\)"
msgstr ""

#: of tvm.tir.op.comm_reducer:1 tvm.tir:1:<autosummary>:1
msgid "Create a commutative reducer for reduction."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`min <tvm.tir.min>`\\ \\(expr\\, axis\\[\\, where\\, init\\]\\)"
msgstr ""

#: of tvm.tir.op.comm_reducer.<locals>.reducer:1 tvm.tir:1:<autosummary>:1
msgid "Create a min expression over axis."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`max <tvm.tir.max>`\\ \\(expr\\, axis\\[\\, where\\, init\\]\\)"
msgstr ""

#: of tvm.tir.op.comm_reducer.<locals>.reducer:1 tvm.tir:1:<autosummary>:1
msgid "Create a max expression over axis."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ":py:obj:`sum <tvm.tir.sum>`\\ \\(expr\\, axis\\[\\, where\\, init\\]\\)"
msgstr ""

#: of tvm.tir.op.comm_reducer.<locals>.reducer:1 tvm.tir:1:<autosummary>:1
msgid "Create a sum expression over axis."
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
":py:obj:`q_multiply_shift <tvm.tir.q_multiply_shift>`\\ \\(x\\, y\\, q\\,"
" s\\)"
msgstr ""

#: of tvm.tir:1:<autosummary>:1
msgid ""
"Execute a multiplication between two Q-numbers x and y followed by a "
"right shift s."
msgstr ""

#: of tvm.tir:1
msgid "**Exceptions:**"
msgstr ""

#: of tvm.tir.buffer.Buffer:1:<autosummary>:1
msgid ":py:obj:`ScheduleError <tvm.tir.ScheduleError>`\\"
msgstr ""

#: of tvm.tir.buffer.Buffer:1:<autosummary>:1
#: tvm.tir.schedule.schedule.ScheduleError:1
msgid "Error that happens during TensorIR scheduling."
msgstr ""

#: of tvm.tir.buffer.Buffer:3
msgid ""
"Buffer provide a way to represent data layout specialization of data "
"structure in TVM."
msgstr ""

#: of tvm.tir.buffer.Buffer:6
msgid ""
"Do not construct directly, use :py:func:`~decl_buffer` instead. See the "
"documentation of :py:func:`decl_buffer` for more details."
msgstr ""

#: of tvm.tir.buffer.Buffer:11
msgid ":obj:`decl_buffer`"
msgstr ""

#: of tvm.tir.buffer.Buffer:12
msgid "Declare a buffer"
msgstr ""

#: of tvm.tir.buffer.Buffer:1 tvm.tir.data_layout.BijectiveLayout:1
#: tvm.tir.data_layout.Layout:1 tvm.tir.function.PrimFunc:1
#: tvm.tir.schedule.block_scope.BlockScope:1
#: tvm.tir.schedule.block_scope.StmtSRef:1 tvm.tir.schedule.schedule.Schedule:1
#: tvm.tir.schedule.state.ScheduleState:1
msgid "**Methods:**"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ""
":py:obj:`access_ptr <tvm.tir.Buffer.access_ptr>`\\ \\(access\\_mask\\[\\,"
" ptr\\_type\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1
#: tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid "Get an access pointer to the head of buffer."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ":py:obj:`vload <tvm.tir.Buffer.vload>`\\ \\(begin\\[\\, dtype\\]\\)"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
#: tvm.tir.buffer.Buffer.vload:1
msgid "Generate an Expr that loads dtype from begin index."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ":py:obj:`vstore <tvm.tir.Buffer.vstore>`\\ \\(begin\\, value\\)"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
#: tvm.tir.buffer.Buffer.vstore:1
msgid "Generate a Stmt that store value into begin index."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ":py:obj:`scope <tvm.tir.Buffer.scope>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid "Return the storage scope associated with this buffer."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:3
msgid ""
"This is the recommended method to get buffer data ptress when interacting"
" with external functions."
msgstr ""

#: of tvm.tir.analysis.analysis.calculate_workspace_bytes
#: tvm.tir.analysis.analysis.detect_buffer_access_lca
#: tvm.tir.analysis.analysis.expr_deep_equal
#: tvm.tir.analysis.analysis.get_block_access_region
#: tvm.tir.analysis.analysis.get_block_read_write_region
#: tvm.tir.analysis.analysis.verify_gpu_code
#: tvm.tir.analysis.analysis.verify_memory tvm.tir.analysis.analysis.verify_ssa
#: tvm.tir.buffer.Buffer.access_ptr tvm.tir.buffer.Buffer.vload
#: tvm.tir.buffer.Buffer.vstore tvm.tir.buffer.decl_buffer
#: tvm.tir.data_layout.BijectiveLayout
#: tvm.tir.data_layout.BijectiveLayout.backward_index
#: tvm.tir.data_layout.BijectiveLayout.backward_shape
#: tvm.tir.data_layout.BijectiveLayout.forward_index
#: tvm.tir.data_layout.BijectiveLayout.forward_shape
#: tvm.tir.data_layout.Layout.factor_of tvm.tir.data_layout.Layout.index_of
#: tvm.tir.data_layout.bijective_layout tvm.tir.data_layout.layout
#: tvm.tir.expr.Add tvm.tir.expr.And tvm.tir.expr.Broadcast
#: tvm.tir.expr.BufferLoad tvm.tir.expr.Call tvm.tir.expr.Cast
#: tvm.tir.expr.CommReducer tvm.tir.expr.Div tvm.tir.expr.EQ
#: tvm.tir.expr.FloatImm tvm.tir.expr.FloorDiv tvm.tir.expr.FloorMod
#: tvm.tir.expr.GE tvm.tir.expr.GT tvm.tir.expr.IntImm tvm.tir.expr.IterVar
#: tvm.tir.expr.LE tvm.tir.expr.LT tvm.tir.expr.Let tvm.tir.expr.Load
#: tvm.tir.expr.Max tvm.tir.expr.Min tvm.tir.expr.Mod tvm.tir.expr.Mul
#: tvm.tir.expr.NE tvm.tir.expr.Not tvm.tir.expr.Or tvm.tir.expr.ProducerLoad
#: tvm.tir.expr.Ramp tvm.tir.expr.Reduce tvm.tir.expr.Select
#: tvm.tir.expr.Shuffle tvm.tir.expr.SizeVar tvm.tir.expr.StringImm
#: tvm.tir.expr.Sub tvm.tir.expr.Var tvm.tir.function.PrimFunc
#: tvm.tir.function.PrimFunc.script tvm.tir.function.PrimFunc.specialize
#: tvm.tir.function.PrimFunc.with_body tvm.tir.op.abs tvm.tir.op.acos
#: tvm.tir.op.acosh tvm.tir.op.all tvm.tir.op.any tvm.tir.op.asin
#: tvm.tir.op.asinh tvm.tir.op.atan tvm.tir.op.atan2 tvm.tir.op.atanh
#: tvm.tir.op.call_extern tvm.tir.op.call_intrin tvm.tir.op.call_llvm_intrin
#: tvm.tir.op.call_llvm_pure_intrin tvm.tir.op.call_packed
#: tvm.tir.op.call_pure_extern tvm.tir.op.ceil tvm.tir.op.clz
#: tvm.tir.op.comm_reducer tvm.tir.op.comm_reducer.<locals>.reducer
#: tvm.tir.op.copysign tvm.tir.op.cos tvm.tir.op.cosh tvm.tir.op.div
#: tvm.tir.op.erf tvm.tir.op.exp tvm.tir.op.exp10 tvm.tir.op.exp2
#: tvm.tir.op.floor tvm.tir.op.floordiv tvm.tir.op.floormod tvm.tir.op.fmod
#: tvm.tir.op.hypot tvm.tir.op.if_then_else tvm.tir.op.indexdiv
#: tvm.tir.op.indexmod tvm.tir.op.isfinite tvm.tir.op.isinf tvm.tir.op.isnan
#: tvm.tir.op.ldexp tvm.tir.op.log tvm.tir.op.log10 tvm.tir.op.log1p
#: tvm.tir.op.log2 tvm.tir.op.max_value tvm.tir.op.min_value
#: tvm.tir.op.nearbyint tvm.tir.op.nextafter tvm.tir.op.popcount
#: tvm.tir.op.power tvm.tir.op.q_multiply_shift tvm.tir.op.ret tvm.tir.op.round
#: tvm.tir.op.rsqrt tvm.tir.op.sigmoid tvm.tir.op.sin tvm.tir.op.sinh
#: tvm.tir.op.sqrt tvm.tir.op.tan tvm.tir.op.tanh tvm.tir.op.trace
#: tvm.tir.op.trunc tvm.tir.op.truncdiv tvm.tir.op.truncmod
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_dst
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src
#: tvm.tir.schedule.schedule.Schedule.bind
#: tvm.tir.schedule.schedule.Schedule.cache_read
#: tvm.tir.schedule.schedule.Schedule.cache_write
#: tvm.tir.schedule.schedule.Schedule.compute_at
#: tvm.tir.schedule.schedule.Schedule.compute_inline
#: tvm.tir.schedule.schedule.Schedule.decompose_reduction
#: tvm.tir.schedule.schedule.Schedule.fuse
#: tvm.tir.schedule.schedule.Schedule.get
#: tvm.tir.schedule.schedule.Schedule.get_block
#: tvm.tir.schedule.schedule.Schedule.get_child_blocks
#: tvm.tir.schedule.schedule.Schedule.get_consumers
#: tvm.tir.schedule.schedule.Schedule.get_loops
#: tvm.tir.schedule.schedule.Schedule.get_producers
#: tvm.tir.schedule.schedule.Schedule.get_sref
#: tvm.tir.schedule.schedule.Schedule.parallel
#: tvm.tir.schedule.schedule.Schedule.remove_rv
#: tvm.tir.schedule.schedule.Schedule.reorder
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_inline
#: tvm.tir.schedule.schedule.Schedule.rfactor
#: tvm.tir.schedule.schedule.Schedule.sample_categorical
#: tvm.tir.schedule.schedule.Schedule.sample_perfect_tile
#: tvm.tir.schedule.schedule.Schedule.seed
#: tvm.tir.schedule.schedule.Schedule.show
#: tvm.tir.schedule.schedule.Schedule.split
#: tvm.tir.schedule.schedule.Schedule.storage_align
#: tvm.tir.schedule.schedule.Schedule.unroll
#: tvm.tir.schedule.schedule.Schedule.vectorize
#: tvm.tir.schedule.state.ScheduleState
#: tvm.tir.schedule.state.ScheduleState.get_block_scope
#: tvm.tir.schedule.state.ScheduleState.get_sref
#: tvm.tir.schedule.state.ScheduleState.replace tvm.tir.stmt.Allocate
#: tvm.tir.stmt.AssertStmt tvm.tir.stmt.AttrStmt tvm.tir.stmt.Block
#: tvm.tir.stmt.BlockRealize tvm.tir.stmt.BufferRealize
#: tvm.tir.stmt.BufferRegion tvm.tir.stmt.BufferStore tvm.tir.stmt.Evaluate
#: tvm.tir.stmt.For tvm.tir.stmt.IfThenElse tvm.tir.stmt.LetStmt
#: tvm.tir.stmt.MatchBufferRegion tvm.tir.stmt.Prefetch
#: tvm.tir.stmt.ProducerRealize tvm.tir.stmt.ProducerStore tvm.tir.stmt.SeqStmt
#: tvm.tir.stmt.Store tvm.tir.stmt.While tvm.tir.stmt.stmt_list
#: tvm.tir.stmt.stmt_seq tvm.tir.stmt_functor.ir_transform
#: tvm.tir.stmt_functor.post_order_visit tvm.tir.stmt_functor.substitute
#: tvm.tir.transform.function_pass.prim_func_pass
#: tvm.tir.transform.transform.Apply tvm.tir.transform.transform.Filter
#: tvm.tir.transform.transform.HoistIfThenElse
#: tvm.tir.transform.transform.InjectCopyIntrin
#: tvm.tir.transform.transform.LiftAttrScope
#: tvm.tir.transform.transform.MakePackedAPI
#: tvm.tir.transform.transform.NarrowDataType
#: tvm.tir.transform.transform.StorageFlatten
#: tvm.tir.transform.transform.ThreadSync
#: tvm.tir.transform.transform.VectorizeLoop
msgid "Parameters"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:6
msgid ""
"The access pattern MASK. Indicate whether the access will read or write "
"to the data content."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:9
msgid ""
"The data type of the result pointer. Do not specify unless we want to "
"cast pointer to specific type."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:12
msgid ""
"The number of lanes for the data type. This value is greater than one for"
" vector types."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:15
msgid ""
"The offset of pointer. We can use it to offset by the number of elements "
"from the address of ptr."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:20
#: tvm.tir.function.PrimFunc.specialize:7
#: tvm.tir.schedule.schedule.Schedule.bind:20
#: tvm.tir.schedule.schedule.Schedule.cache_read:18
#: tvm.tir.schedule.schedule.Schedule.cache_write:18
#: tvm.tir.schedule.schedule.Schedule.compute_at:26
#: tvm.tir.schedule.schedule.Schedule.compute_inline:17
#: tvm.tir.schedule.schedule.Schedule.decompose_reduction:26
#: tvm.tir.schedule.schedule.Schedule.fuse:14
#: tvm.tir.schedule.schedule.Schedule.parallel:12
#: tvm.tir.schedule.schedule.Schedule.reorder:15
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at:23
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:20
#: tvm.tir.schedule.schedule.Schedule.rfactor:70
#: tvm.tir.schedule.schedule.Schedule.split:21
#: tvm.tir.schedule.schedule.Schedule.storage_align:18
#: tvm.tir.schedule.schedule.Schedule.unroll:7
#: tvm.tir.schedule.schedule.Schedule.vectorize:12
#: tvm.tir.transform.function_pass.prim_func_pass:25
msgid "Examples"
msgstr ""

#: of tvm.tir.buffer.Buffer.vload:3 tvm.tir.buffer.Buffer.vstore:3
msgid "The beginning index in unit of Buffer.dtype"
msgstr ""

#: of tvm.tir.buffer.Buffer.vload:5
msgid ""
"The data type to be loaded, can be vector type which have lanes that is "
"multiple of Buffer.dtype"
msgstr ""

#: of tvm.tir.analysis.analysis.calculate_workspace_bytes
#: tvm.tir.analysis.analysis.detect_buffer_access_lca
#: tvm.tir.analysis.analysis.expr_deep_equal
#: tvm.tir.analysis.analysis.get_block_access_region
#: tvm.tir.analysis.analysis.get_block_read_write_region
#: tvm.tir.analysis.analysis.verify_gpu_code
#: tvm.tir.analysis.analysis.verify_memory tvm.tir.analysis.analysis.verify_ssa
#: tvm.tir.buffer.Buffer.vload tvm.tir.buffer.Buffer.vstore
#: tvm.tir.buffer.decl_buffer
#: tvm.tir.data_layout.BijectiveLayout.backward_index
#: tvm.tir.data_layout.BijectiveLayout.backward_shape
#: tvm.tir.data_layout.BijectiveLayout.forward_index
#: tvm.tir.data_layout.BijectiveLayout.forward_shape
#: tvm.tir.data_layout.Layout.factor_of tvm.tir.data_layout.Layout.index_of
#: tvm.tir.data_layout.bijective_layout tvm.tir.data_layout.layout
#: tvm.tir.function.PrimFunc.script tvm.tir.function.PrimFunc.specialize
#: tvm.tir.function.PrimFunc.with_body tvm.tir.op.abs tvm.tir.op.acos
#: tvm.tir.op.acosh tvm.tir.op.all tvm.tir.op.any tvm.tir.op.asin
#: tvm.tir.op.asinh tvm.tir.op.atan tvm.tir.op.atan2 tvm.tir.op.atanh
#: tvm.tir.op.call_extern tvm.tir.op.call_intrin tvm.tir.op.call_llvm_intrin
#: tvm.tir.op.call_llvm_pure_intrin tvm.tir.op.call_packed
#: tvm.tir.op.call_pure_extern tvm.tir.op.ceil tvm.tir.op.clz
#: tvm.tir.op.comm_reducer tvm.tir.op.comm_reducer.<locals>.reducer
#: tvm.tir.op.copysign tvm.tir.op.cos tvm.tir.op.cosh tvm.tir.op.div
#: tvm.tir.op.erf tvm.tir.op.exp tvm.tir.op.exp10 tvm.tir.op.exp2
#: tvm.tir.op.floor tvm.tir.op.floordiv tvm.tir.op.floormod tvm.tir.op.fmod
#: tvm.tir.op.hypot tvm.tir.op.if_then_else tvm.tir.op.indexdiv
#: tvm.tir.op.indexmod tvm.tir.op.isfinite tvm.tir.op.isinf tvm.tir.op.isnan
#: tvm.tir.op.ldexp tvm.tir.op.log tvm.tir.op.log10 tvm.tir.op.log1p
#: tvm.tir.op.log2 tvm.tir.op.max_value tvm.tir.op.min_value
#: tvm.tir.op.nearbyint tvm.tir.op.nextafter tvm.tir.op.popcount
#: tvm.tir.op.power tvm.tir.op.q_multiply_shift tvm.tir.op.ret tvm.tir.op.round
#: tvm.tir.op.rsqrt tvm.tir.op.sigmoid tvm.tir.op.sin tvm.tir.op.sinh
#: tvm.tir.op.sqrt tvm.tir.op.tan tvm.tir.op.tanh tvm.tir.op.trace
#: tvm.tir.op.trunc tvm.tir.op.truncdiv tvm.tir.op.truncmod
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_dst
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src
#: tvm.tir.schedule.schedule.Schedule.cache_read
#: tvm.tir.schedule.schedule.Schedule.cache_write
#: tvm.tir.schedule.schedule.Schedule.copy
#: tvm.tir.schedule.schedule.Schedule.decompose_reduction
#: tvm.tir.schedule.schedule.Schedule.fork_seed
#: tvm.tir.schedule.schedule.Schedule.fuse
#: tvm.tir.schedule.schedule.Schedule.get
#: tvm.tir.schedule.schedule.Schedule.get_block
#: tvm.tir.schedule.schedule.Schedule.get_child_blocks
#: tvm.tir.schedule.schedule.Schedule.get_consumers
#: tvm.tir.schedule.schedule.Schedule.get_loops
#: tvm.tir.schedule.schedule.Schedule.get_producers
#: tvm.tir.schedule.schedule.Schedule.get_sref
#: tvm.tir.schedule.schedule.Schedule.rfactor
#: tvm.tir.schedule.schedule.Schedule.sample_categorical
#: tvm.tir.schedule.schedule.Schedule.sample_perfect_tile
#: tvm.tir.schedule.schedule.Schedule.show
#: tvm.tir.schedule.schedule.Schedule.split
#: tvm.tir.schedule.state.ScheduleState.get_block_scope
#: tvm.tir.schedule.state.ScheduleState.get_sref tvm.tir.stmt.stmt_list
#: tvm.tir.stmt.stmt_seq tvm.tir.stmt_functor.ir_transform
#: tvm.tir.stmt_functor.substitute
#: tvm.tir.transform.function_pass.prim_func_pass
#: tvm.tir.transform.transform.Apply
#: tvm.tir.transform.transform.BF16CastElimination
#: tvm.tir.transform.transform.BF16Legalize
#: tvm.tir.transform.transform.BF16Promote
#: tvm.tir.transform.transform.BF16TypeLowering
#: tvm.tir.transform.transform.CoProcSync
#: tvm.tir.transform.transform.CombineContextCall
#: tvm.tir.transform.transform.CompactBufferAllocation
#: tvm.tir.transform.transform.ConvertBlocksToOpaque
#: tvm.tir.transform.transform.ConvertForLoopsToSerial
#: tvm.tir.transform.transform.DecorateDeviceScope
#: tvm.tir.transform.transform.Filter tvm.tir.transform.transform.FlattenBuffer
#: tvm.tir.transform.transform.HoistIfThenElse
#: tvm.tir.transform.transform.InferFragment
#: tvm.tir.transform.transform.InjectCopyIntrin
#: tvm.tir.transform.transform.InjectDoubleBuffer
#: tvm.tir.transform.transform.InjectPrefetch
#: tvm.tir.transform.transform.InjectVirtualThread
#: tvm.tir.transform.transform.InstrumentBoundCheckers
#: tvm.tir.transform.transform.LegalizePackedCalls
#: tvm.tir.transform.transform.LiftAttrScope
#: tvm.tir.transform.transform.LoopPartition
#: tvm.tir.transform.transform.LowerCustomDatatypes
#: tvm.tir.transform.transform.LowerDeviceStorageAccessInfo
#: tvm.tir.transform.transform.LowerInitBlock
#: tvm.tir.transform.transform.LowerIntrin
#: tvm.tir.transform.transform.LowerMatchBuffer
#: tvm.tir.transform.transform.LowerTVMBuiltin
#: tvm.tir.transform.transform.LowerThreadAllreduce
#: tvm.tir.transform.transform.LowerWarpMemory
#: tvm.tir.transform.transform.MakePackedAPI
#: tvm.tir.transform.transform.MakeUnpackedAPI
#: tvm.tir.transform.transform.MergeDynamicSharedMemoryAllocations
#: tvm.tir.transform.transform.NarrowDataType
#: tvm.tir.transform.transform.PlanAndUpdateBufferAllocationLocation
#: tvm.tir.transform.transform.RemoveNoOp
#: tvm.tir.transform.transform.RewriteUnsafeSelect
#: tvm.tir.transform.transform.Simplify tvm.tir.transform.transform.SkipAssert
#: tvm.tir.transform.transform.SplitHostDevice
#: tvm.tir.transform.transform.StorageFlatten
#: tvm.tir.transform.transform.StorageRewrite
#: tvm.tir.transform.transform.TextureFlatten
#: tvm.tir.transform.transform.ThreadSync
#: tvm.tir.transform.transform.UnifyThreadBinding
#: tvm.tir.transform.transform.UnrollLoop
#: tvm.tir.transform.transform.VectorizeLoop
#: tvm.tir.transform.transform.VerifyMemory
msgid "Returns"
msgstr ""

#: of tvm.tir.buffer.Buffer.vload:9
msgid "**load** -- The corresponding load expression."
msgstr ""

#: of tvm.tir.analysis.analysis.calculate_workspace_bytes
#: tvm.tir.analysis.analysis.detect_buffer_access_lca
#: tvm.tir.analysis.analysis.expr_deep_equal
#: tvm.tir.analysis.analysis.get_block_access_region
#: tvm.tir.analysis.analysis.get_block_read_write_region
#: tvm.tir.analysis.analysis.verify_gpu_code
#: tvm.tir.analysis.analysis.verify_memory tvm.tir.analysis.analysis.verify_ssa
#: tvm.tir.buffer.Buffer.vload tvm.tir.buffer.Buffer.vstore
#: tvm.tir.buffer.decl_buffer
#: tvm.tir.data_layout.BijectiveLayout.backward_index
#: tvm.tir.data_layout.BijectiveLayout.backward_shape
#: tvm.tir.data_layout.BijectiveLayout.forward_index
#: tvm.tir.data_layout.BijectiveLayout.forward_shape
#: tvm.tir.data_layout.Layout.factor_of tvm.tir.data_layout.Layout.index_of
#: tvm.tir.data_layout.bijective_layout tvm.tir.data_layout.layout
#: tvm.tir.function.PrimFunc.script tvm.tir.function.PrimFunc.specialize
#: tvm.tir.function.PrimFunc.with_body tvm.tir.op.abs tvm.tir.op.acos
#: tvm.tir.op.acosh tvm.tir.op.all tvm.tir.op.any tvm.tir.op.asin
#: tvm.tir.op.asinh tvm.tir.op.atan tvm.tir.op.atan2 tvm.tir.op.atanh
#: tvm.tir.op.call_extern tvm.tir.op.call_intrin tvm.tir.op.call_llvm_intrin
#: tvm.tir.op.call_llvm_pure_intrin tvm.tir.op.call_packed
#: tvm.tir.op.call_pure_extern tvm.tir.op.ceil tvm.tir.op.clz
#: tvm.tir.op.comm_reducer tvm.tir.op.comm_reducer.<locals>.reducer
#: tvm.tir.op.copysign tvm.tir.op.cos tvm.tir.op.cosh tvm.tir.op.div
#: tvm.tir.op.erf tvm.tir.op.exp tvm.tir.op.exp10 tvm.tir.op.exp2
#: tvm.tir.op.floor tvm.tir.op.floordiv tvm.tir.op.floormod tvm.tir.op.fmod
#: tvm.tir.op.hypot tvm.tir.op.if_then_else tvm.tir.op.indexdiv
#: tvm.tir.op.indexmod tvm.tir.op.isfinite tvm.tir.op.isinf tvm.tir.op.isnan
#: tvm.tir.op.ldexp tvm.tir.op.log tvm.tir.op.log10 tvm.tir.op.log1p
#: tvm.tir.op.log2 tvm.tir.op.max_value tvm.tir.op.min_value
#: tvm.tir.op.nearbyint tvm.tir.op.nextafter tvm.tir.op.popcount
#: tvm.tir.op.power tvm.tir.op.q_multiply_shift tvm.tir.op.ret tvm.tir.op.round
#: tvm.tir.op.rsqrt tvm.tir.op.sigmoid tvm.tir.op.sin tvm.tir.op.sinh
#: tvm.tir.op.sqrt tvm.tir.op.tan tvm.tir.op.tanh tvm.tir.op.trace
#: tvm.tir.op.trunc tvm.tir.op.truncdiv tvm.tir.op.truncmod
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_dst
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src
#: tvm.tir.schedule.schedule.Schedule.cache_read
#: tvm.tir.schedule.schedule.Schedule.cache_write
#: tvm.tir.schedule.schedule.Schedule.copy
#: tvm.tir.schedule.schedule.Schedule.decompose_reduction
#: tvm.tir.schedule.schedule.Schedule.fork_seed
#: tvm.tir.schedule.schedule.Schedule.fuse
#: tvm.tir.schedule.schedule.Schedule.get
#: tvm.tir.schedule.schedule.Schedule.get_block
#: tvm.tir.schedule.schedule.Schedule.get_child_blocks
#: tvm.tir.schedule.schedule.Schedule.get_consumers
#: tvm.tir.schedule.schedule.Schedule.get_loops
#: tvm.tir.schedule.schedule.Schedule.get_producers
#: tvm.tir.schedule.schedule.Schedule.get_sref
#: tvm.tir.schedule.schedule.Schedule.rfactor
#: tvm.tir.schedule.schedule.Schedule.sample_categorical
#: tvm.tir.schedule.schedule.Schedule.sample_perfect_tile
#: tvm.tir.schedule.schedule.Schedule.show
#: tvm.tir.schedule.schedule.Schedule.split
#: tvm.tir.schedule.state.ScheduleState.get_block_scope
#: tvm.tir.schedule.state.ScheduleState.get_sref tvm.tir.stmt.stmt_list
#: tvm.tir.stmt.stmt_seq tvm.tir.stmt_functor.ir_transform
#: tvm.tir.stmt_functor.substitute
#: tvm.tir.transform.function_pass.prim_func_pass
#: tvm.tir.transform.transform.Apply
#: tvm.tir.transform.transform.BF16CastElimination
#: tvm.tir.transform.transform.BF16Legalize
#: tvm.tir.transform.transform.BF16Promote
#: tvm.tir.transform.transform.BF16TypeLowering
#: tvm.tir.transform.transform.CoProcSync
#: tvm.tir.transform.transform.CombineContextCall
#: tvm.tir.transform.transform.CompactBufferAllocation
#: tvm.tir.transform.transform.ConvertBlocksToOpaque
#: tvm.tir.transform.transform.ConvertForLoopsToSerial
#: tvm.tir.transform.transform.DecorateDeviceScope
#: tvm.tir.transform.transform.Filter tvm.tir.transform.transform.FlattenBuffer
#: tvm.tir.transform.transform.HoistIfThenElse
#: tvm.tir.transform.transform.InferFragment
#: tvm.tir.transform.transform.InjectCopyIntrin
#: tvm.tir.transform.transform.InjectDoubleBuffer
#: tvm.tir.transform.transform.InjectPrefetch
#: tvm.tir.transform.transform.InjectVirtualThread
#: tvm.tir.transform.transform.InstrumentBoundCheckers
#: tvm.tir.transform.transform.LegalizePackedCalls
#: tvm.tir.transform.transform.LiftAttrScope
#: tvm.tir.transform.transform.LoopPartition
#: tvm.tir.transform.transform.LowerCustomDatatypes
#: tvm.tir.transform.transform.LowerDeviceStorageAccessInfo
#: tvm.tir.transform.transform.LowerInitBlock
#: tvm.tir.transform.transform.LowerIntrin
#: tvm.tir.transform.transform.LowerMatchBuffer
#: tvm.tir.transform.transform.LowerTVMBuiltin
#: tvm.tir.transform.transform.LowerThreadAllreduce
#: tvm.tir.transform.transform.LowerWarpMemory
#: tvm.tir.transform.transform.MakePackedAPI
#: tvm.tir.transform.transform.MakeUnpackedAPI
#: tvm.tir.transform.transform.MergeDynamicSharedMemoryAllocations
#: tvm.tir.transform.transform.NarrowDataType
#: tvm.tir.transform.transform.PlanAndUpdateBufferAllocationLocation
#: tvm.tir.transform.transform.RemoveNoOp
#: tvm.tir.transform.transform.RewriteUnsafeSelect
#: tvm.tir.transform.transform.Simplify tvm.tir.transform.transform.SkipAssert
#: tvm.tir.transform.transform.SplitHostDevice
#: tvm.tir.transform.transform.StorageFlatten
#: tvm.tir.transform.transform.StorageRewrite
#: tvm.tir.transform.transform.TextureFlatten
#: tvm.tir.transform.transform.ThreadSync
#: tvm.tir.transform.transform.UnifyThreadBinding
#: tvm.tir.transform.transform.UnrollLoop
#: tvm.tir.transform.transform.VectorizeLoop
#: tvm.tir.transform.transform.VerifyMemory
msgid "Return type"
msgstr ""

#: of tvm.tir.buffer.Buffer.vstore:5 tvm.tir.stmt.ProducerStore:5
msgid "The value to be stored."
msgstr ""

#: of tvm.tir.buffer.Buffer.vstore:8
msgid "**store** -- The corresponding store stmt."
msgstr ""

#: of tvm.tir.buffer.Buffer.scope:1
msgid ""
"Return the storage scope associated with this buffer. :returns: **scope**"
" -- The storage scope associated with this buffer. :rtype: str"
msgstr ""

#: of tvm.tir.buffer.decl_buffer:3
msgid ""
"Normally buffer is created automatically during lower and build. This is "
"only needed if user want to specify their own buffer layout."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:6
msgid "See the note below for detailed discussion on usage of buffer."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:8
msgid "The shape of the buffer."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:10 tvm.tir.stmt.Allocate:5
msgid "The data type of the buffer."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:12
msgid "The name of the buffer."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:14
msgid "The data pointer in the buffer."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:16
msgid "The stride of the buffer."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:18
msgid ""
"The beginning offset of the array to data. In terms of number of elements"
" of dtype."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:21
msgid ""
"The storage scope of the buffer, if not global. If scope equals empty "
"string, it means it is global memory."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:24
msgid ""
"The alignment of data pointer in bytes. If -1 is passed, the alignment "
"will be set to TVM's internal default."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:27
msgid ""
"The factor of elem_offset field, when set, elem_offset is required to be "
"multiple of offset_factor. If 0 is pssed, the alignment will be set to 1."
" if non-zero is passed, we will created a Var for elem_offset if "
"elem_offset is not None."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:32
msgid ""
"auto_broadcast buffer allows one to implement broadcast computation "
"without considering whether dimension size equals to one. TVM maps "
"buffer[i][j][k] -> buffer[i][0][k] if dimension j's shape equals 1."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:36
msgid "The location of the decl_buffer creation in the source."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:39
msgid "**buffer** -- The created buffer"
msgstr ""

#: of tvm.tir.buffer.decl_buffer:43 tvm.tir.op.comm_reducer:17
#: tvm.tir.op.comm_reducer.<locals>.reducer:14
#: tvm.tir.transform.transform.CompactBufferAllocation:6
msgid "Example"
msgstr ""

#: of tvm.tir.buffer.decl_buffer:44
msgid ""
"Here's an example of how broadcast buffer can be used to define a "
"symbolic broadcast operation,"
msgstr ""

#: of tvm.tir.buffer.decl_buffer:67
msgid ""
"Buffer data structure reflects the DLTensor structure in dlpack. While "
"DLTensor data structure is very general, it is usually helpful to create "
"function that only handles specific case of data structure and make "
"compiled function benefit from it."
msgstr ""

#: of tvm.tir.buffer.decl_buffer:72
msgid ""
"If user pass strides and elem_offset is passed as None when constructing "
"the function, then the function will be specialized for the DLTensor that"
" is compact and aligned. If user pass a fully generic symbolic array to "
"the strides, then the resulting function becomes fully generic."
msgstr ""

#: of tvm.tir.data_layout.Layout:1
msgid ""
"Layout is composed of upper cases, lower cases and numbers, where upper "
"case indicates a primal axis and the corresponding lower case with factor"
" size indicates the subordinate axis. For example, NCHW16c can describe a"
" 5-D tensor of [batch_size, channel, height, width, channel_block]. Here "
"subordinate axis channel_block=16 is the factor size of the primal axis C"
" (channel)."
msgstr ""

#: of tvm.tir.data_layout.Layout:10
msgid ":obj:`layout`"
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout:15 tvm.tir.data_layout.Layout:11
msgid "Declare a layout"
msgstr ""

#: of tvm.tir.data_layout.Layout.index_of:1:<autosummary>:1
msgid ":py:obj:`index_of <tvm.tir.Layout.index_of>`\\ \\(axis\\)"
msgstr ""

#: of tvm.tir.data_layout.Layout.index_of:1
#: tvm.tir.data_layout.Layout.index_of:1:<autosummary>:1
msgid "Get the index of an axis"
msgstr ""

#: of tvm.tir.data_layout.Layout.index_of:1:<autosummary>:1
msgid ":py:obj:`factor_of <tvm.tir.Layout.factor_of>`\\ \\(axis\\)"
msgstr ""

#: of tvm.tir.data_layout.Layout.factor_of:1
#: tvm.tir.data_layout.Layout.index_of:1:<autosummary>:1
msgid "Get the factor size of the subordinate axis."
msgstr ""

#: of tvm.tir.data_layout.Layout.factor_of:3
#: tvm.tir.data_layout.Layout.index_of:3
msgid "The axis name, need to be [a-z,A-Z]"
msgstr ""

#: of tvm.tir.data_layout.Layout.index_of:6
msgid "**index** -- The index of the axis, -1 if not found."
msgstr ""

#: of tvm.tir.data_layout.Layout.factor_of:6
msgid ""
"**factor** -- the size of the subordinate-axis of axis (if axis is a "
"primal-axis), or the size of axis itself (if axis is a subordinate-axis)."
" Return -1 if axis is not in the layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout:1
msgid ""
"Bijective mapping for two layouts (src-layout and dst-layout). It "
"provides shape and index conversion between each other."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout:4
msgid ""
"Do not construct directly, use :any:`bijective_layout` instead. See the "
"documentation of :any:`bijective_layout` for more details."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout:7
#: tvm.tir.data_layout.bijective_layout:3
msgid "source layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout:9
#: tvm.tir.data_layout.bijective_layout:5
msgid "destination layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout:14
msgid ":obj:`bijective_layout`"
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
msgid ""
":py:obj:`forward_index <tvm.tir.BijectiveLayout.forward_index>`\\ "
"\\(index\\)"
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:1
#: tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
msgid "Given the indices of the src-layout, infer the dst index."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
msgid ""
":py:obj:`backward_index <tvm.tir.BijectiveLayout.backward_index>`\\ "
"\\(index\\)"
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.backward_index:1
#: tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
msgid "Given the indices of the dst-layout, infer the src index."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
msgid ""
":py:obj:`forward_shape <tvm.tir.BijectiveLayout.forward_shape>`\\ "
"\\(shape\\)"
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
#: tvm.tir.data_layout.BijectiveLayout.forward_shape:1
msgid "Given the shape of the src-layout, infer the dst shape."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
msgid ""
":py:obj:`backward_shape <tvm.tir.BijectiveLayout.backward_shape>`\\ "
"\\(shape\\)"
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.backward_shape:1
#: tvm.tir.data_layout.BijectiveLayout.forward_index:1:<autosummary>:1
msgid "Given the shape of the dst-layout, infer the src shape."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:3
msgid "The indices in src-layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_index:6
msgid "**dst_index** -- The inferred indices in dst-layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.backward_index:3
msgid "The indices in dst-layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.backward_index:6
msgid "**src_index** -- The inferred indices in src-layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_shape:3
msgid "The shape in src-layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.forward_shape:6
msgid "**dst_shape** -- The inferred shape in dst-layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.backward_shape:3
msgid "The shape in dst-layout."
msgstr ""

#: of tvm.tir.data_layout.BijectiveLayout.backward_shape:6
msgid "**src_shape** -- The inferred shape in src-layout."
msgstr ""

#: of tvm.tir.data_layout.bijective_layout:8
msgid "**bijective_layout** -- The created bijective layout"
msgstr ""

#: of tvm.tir.data_layout.layout:3
msgid ""
"A layout representation is composed of upper cases, lower cases and "
"numbers, where upper case indicates a primal axis and the corresponding "
"lower case with factor size indicates the subordinate axis. For example, "
"NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width,"
" channel_block]. Here subordinate axis channel_block=16 is the factor "
"size of the primal axis C (channel)."
msgstr ""

#: of tvm.tir.data_layout.layout:12
msgid "**layout** -- The created layout"
msgstr ""

#: of tvm.tir.expr.SizeVar:4 tvm.tir.expr.Var:3
msgid "The name"
msgstr ""

#: of tvm.tir.expr.Cast:3 tvm.tir.expr.FloatImm:3 tvm.tir.expr.IntImm:3
#: tvm.tir.expr.SizeVar:6 tvm.tir.expr.Var:5
msgid "The data type"
msgstr ""

#: of tvm.tir.expr.Add:7 tvm.tir.expr.And:7 tvm.tir.expr.Any:4
#: tvm.tir.expr.Broadcast:7 tvm.tir.expr.BufferLoad:7 tvm.tir.expr.Call:10
#: tvm.tir.expr.Cast:7 tvm.tir.expr.CommReducer:11 tvm.tir.expr.Div:7
#: tvm.tir.expr.EQ:7 tvm.tir.expr.FloatImm:7 tvm.tir.expr.FloorDiv:7
#: tvm.tir.expr.FloorMod:7 tvm.tir.expr.GE:7 tvm.tir.expr.GT:7
#: tvm.tir.expr.IntImm:7 tvm.tir.expr.IterVar:13 tvm.tir.expr.LE:7
#: tvm.tir.expr.LT:7 tvm.tir.expr.Let:9 tvm.tir.expr.Load:11 tvm.tir.expr.Max:7
#: tvm.tir.expr.Min:7 tvm.tir.expr.Mod:7 tvm.tir.expr.Mul:7 tvm.tir.expr.NE:7
#: tvm.tir.expr.Not:5 tvm.tir.expr.Or:7 tvm.tir.expr.ProducerLoad:7
#: tvm.tir.expr.Ramp:9 tvm.tir.expr.Reduce:15 tvm.tir.expr.Select:16
#: tvm.tir.expr.Shuffle:7 tvm.tir.expr.SizeVar:8 tvm.tir.expr.StringImm:5
#: tvm.tir.expr.Sub:7 tvm.tir.expr.Var:7 tvm.tir.function.PrimFunc:13
#: tvm.tir.function.PrimFunc.with_body:5 tvm.tir.stmt.Allocate:15
#: tvm.tir.stmt.AssertStmt:9 tvm.tir.stmt.AttrStmt:11
#: tvm.tir.stmt.BufferRealize:11 tvm.tir.stmt.BufferStore:9
#: tvm.tir.stmt.Evaluate:5 tvm.tir.stmt.For:18 tvm.tir.stmt.IfThenElse:9
#: tvm.tir.stmt.LetStmt:9 tvm.tir.stmt.Prefetch:7
#: tvm.tir.stmt.ProducerRealize:13 tvm.tir.stmt.ProducerStore:9
#: tvm.tir.stmt.SeqStmt:5 tvm.tir.stmt.Store:11 tvm.tir.stmt.While:7
msgid "The location of this itervar in the source code."
msgstr ""

#: of tvm.tir.expr.SizeVar:2
msgid "which is greater or equal to zero."
msgstr ""

#: of tvm.tir.expr.Reduce:3
msgid "The combiner."
msgstr ""

#: of tvm.tir.expr.Reduce:5 tvm.tir.op.comm_reducer.<locals>.reducer:3
msgid "The source expression."
msgstr ""

#: of tvm.tir.expr.Reduce:7
msgid "The iteration domain"
msgstr ""

#: of tvm.tir.expr.Reduce:9
msgid "The reduce condition."
msgstr ""

#: of tvm.tir.expr.Reduce:11
msgid "The value index."
msgstr ""

#: of tvm.tir.expr.Reduce:13
msgid "The initial value for output. This can be an int, float or ProducerLoad"
msgstr ""

#: of tvm.tir.expr.FloatImm:5 tvm.tir.expr.IntImm:5
msgid "The constant value."
msgstr ""

#: of tvm.tir.expr.Cast:5 tvm.tir.expr.StringImm:3
msgid "The value of the function."
msgstr ""

#: of tvm.tir.expr.Add:3 tvm.tir.expr.And:3 tvm.tir.expr.Div:3
#: tvm.tir.expr.EQ:3 tvm.tir.expr.FloorDiv:3 tvm.tir.expr.FloorMod:3
#: tvm.tir.expr.GE:3 tvm.tir.expr.GT:3 tvm.tir.expr.LE:3 tvm.tir.expr.LT:3
#: tvm.tir.expr.Max:3 tvm.tir.expr.Min:3 tvm.tir.expr.Mod:3 tvm.tir.expr.Mul:3
#: tvm.tir.expr.NE:3 tvm.tir.expr.Or:3 tvm.tir.expr.Sub:3
msgid "The left hand operand."
msgstr ""

#: of tvm.tir.expr.Add:5 tvm.tir.expr.And:5 tvm.tir.expr.Div:5
#: tvm.tir.expr.EQ:5 tvm.tir.expr.FloorDiv:5 tvm.tir.expr.FloorMod:5
#: tvm.tir.expr.GE:5 tvm.tir.expr.GT:5 tvm.tir.expr.LE:5 tvm.tir.expr.LT:5
#: tvm.tir.expr.Max:5 tvm.tir.expr.Min:5 tvm.tir.expr.Mod:5 tvm.tir.expr.Mul:5
#: tvm.tir.expr.NE:5 tvm.tir.expr.Or:5 tvm.tir.expr.Sub:5
msgid "The right hand operand."
msgstr ""

#: of tvm.tir.expr.Not:3
msgid "The input value"
msgstr ""

#: of tvm.tir.expr.Select:5
msgid ""
"Select may compute both true_value and false_value. Use "
":py:class:`tvm.tir.if_then_else` instead if you want to get a conditional"
" expression that only evaluates the correct branch."
msgstr ""

#: of tvm.tir.expr.Select:10
msgid "The condition expression."
msgstr ""

#: of tvm.tir.expr.Select:12
msgid "The value to take when condition is true."
msgstr ""

#: of tvm.tir.expr.Select:14
msgid "The value to take when condition is false."
msgstr ""

#: of tvm.tir.expr.BufferLoad:3 tvm.tir.expr.ProducerLoad:3
msgid "The buffer to be loaded."
msgstr ""

#: of tvm.tir.expr.BufferLoad:5 tvm.tir.expr.ProducerLoad:5
msgid "The buffer indices."
msgstr ""

#: of tvm.tir.expr.Load:3 tvm.tir.op.max_value:3 tvm.tir.op.min_value:3
msgid "The data type."
msgstr ""

#: of tvm.tir.expr.Load:5
msgid "The buffer variable in the load expression."
msgstr ""

#: of tvm.tir.expr.Load:7
msgid "The index in the load."
msgstr ""

#: of tvm.tir.expr.Load:9
msgid "The load predicate."
msgstr ""

#: of tvm.tir.expr.Ramp:3
msgid "The base expression."
msgstr ""

#: of tvm.tir.expr.Ramp:5
msgid "The stride of the ramp."
msgstr ""

#: of tvm.tir.expr.Broadcast:5 tvm.tir.expr.Ramp:7
msgid "The lanes of the expression."
msgstr ""

#: of tvm.tir.expr.Broadcast:3
msgid "The value of the expression."
msgstr ""

#: of tvm.tir.expr.Shuffle:3
msgid "The vectors"
msgstr ""

#: of tvm.tir.expr.Shuffle:5
msgid "The indices"
msgstr ""

#: of tvm.tir.expr.Call:3
msgid "The return data type"
msgstr ""

#: of tvm.tir.expr.Call:5
msgid "The function to be called, or the name to the global tvm.Op"
msgstr ""

#: of tvm.tir.expr.Call:8
msgid "The input arguments to the call"
msgstr ""

#: of tvm.tir.expr.Let:3 tvm.tir.stmt.LetStmt:3
msgid "The variable in the binding."
msgstr ""

#: of tvm.tir.expr.Let:5 tvm.tir.stmt.LetStmt:5
msgid "The value in to be binded."
msgstr ""

#: of tvm.tir.expr.Let:7
msgid "The body expression."
msgstr ""

#: of tvm.tir.expr.IterVar:3
msgid "IterVar represents axis iterations in the computation."
msgstr ""

#: of tvm.tir.expr.IterVar:5
msgid "The domain of the iteration."
msgstr ""

#: of tvm.tir.expr.IterVar:7
msgid "The internal variable that is used for iteration."
msgstr ""

#: of tvm.tir.expr.IterVar:9
msgid "The iteration type."
msgstr ""

#: of tvm.tir.expr.IterVar:11
msgid "The thread type tag."
msgstr ""

#: of tvm.tir.expr.IterVar:19
msgid ":obj:`te.thread_axis`"
msgstr ""

#: of tvm.tir.expr.IterVar:19
msgid "Create thread axis IterVar."
msgstr ""

#: of tvm.tir.expr.IterVar:21
msgid ":obj:`te.reduce_axis`"
msgstr ""

#: of tvm.tir.expr.IterVar:22
msgid "Create reduce axis IterVar."
msgstr ""

#: of tvm.tir.expr.CommReducer:3
msgid "The left arguments of the reducer."
msgstr ""

#: of tvm.tir.expr.CommReducer:5
msgid "The right arguments of the reducer."
msgstr ""

#: of tvm.tir.expr.CommReducer:7
msgid "The reduction results."
msgstr ""

#: of tvm.tir.expr.CommReducer:9
msgid "The identity elements."
msgstr ""

#: of tvm.tir.expr.Any:3
msgid "span"
msgstr ""

#: of
msgid "Optional[Span]"
msgstr ""

#: of tvm.tir.stmt.Allocate:11 tvm.tir.stmt.AssertStmt:7
#: tvm.tir.stmt.AttrStmt:9 tvm.tir.stmt.For:11 tvm.tir.stmt.LetStmt:7
#: tvm.tir.stmt.While:5
msgid "The body statement."
msgstr ""

#: of tvm.tir.stmt.AssertStmt:3
msgid "The assert condition."
msgstr ""

#: of tvm.tir.stmt.AssertStmt:5
msgid "The error message."
msgstr ""

#: of tvm.tir.stmt.ForKind:5
msgid ""
"ForKind can change the control flow semantics of the loop and need to be "
"considered in all TIR passes."
msgstr ""

#: of tvm.tir.stmt.For:3
msgid "The loop variable."
msgstr ""

#: of tvm.tir.stmt.For:5
msgid "The beginning value."
msgstr ""

#: of tvm.tir.stmt.For:7
msgid "The length of the loop."
msgstr ""

#: of tvm.tir.stmt.For:9
msgid "The type of the for."
msgstr ""

#: of tvm.tir.stmt.For:13
msgid "The thread this loop binds to. Only valid if kind is ThreadBinding"
msgstr ""

#: of tvm.tir.stmt.Block:19 tvm.tir.stmt.For:16
msgid "Additional annotation hints."
msgstr ""

#: of tvm.tir.stmt.While:3
msgid "The termination condition."
msgstr ""

#: of tvm.tir.stmt.BufferRealize:3 tvm.tir.stmt.BufferStore:3
msgid "The buffer."
msgstr ""

#: of tvm.tir.stmt.BufferRealize:5 tvm.tir.stmt.BufferStore:5
msgid "The value we to be stored."
msgstr ""

#: of tvm.tir.stmt.BufferStore:7
msgid "The indices location to be stored."
msgstr ""

#: of tvm.tir.stmt.BufferRealize:7 tvm.tir.stmt.ProducerRealize:7
msgid "The realize condition."
msgstr ""

#: of tvm.tir.stmt.BufferRealize:9
msgid "The body of the statement."
msgstr ""

#: of tvm.tir.stmt.Store:3
msgid "The buffer Variable."
msgstr ""

#: of tvm.tir.stmt.Store:5
msgid "The value we want to store."
msgstr ""

#: of tvm.tir.stmt.Store:7
msgid "The index in the store expression."
msgstr ""

#: of tvm.tir.stmt.Store:9
msgid "The store predicate."
msgstr ""

#: of tvm.tir.stmt.ProducerRealize:3 tvm.tir.stmt.ProducerStore:3
msgid "The data producer."
msgstr ""

#: of tvm.tir.stmt.ProducerStore:7
msgid "The index arguments of the store."
msgstr ""

#: of tvm.tir.stmt.Allocate:3
msgid "The buffer variable."
msgstr ""

#: of tvm.tir.stmt.Allocate:7
msgid "The extents of the allocate"
msgstr ""

#: of tvm.tir.stmt.Allocate:9
msgid "The condition."
msgstr ""

#: of tvm.tir.stmt.Allocate:13
msgid "Additional annotation hints"
msgstr ""

#: of tvm.tir.stmt.AttrStmt:3
msgid "The node to annotate the attribute"
msgstr ""

#: of tvm.tir.stmt.AttrStmt:5
msgid "Attribute type key."
msgstr ""

#: of tvm.tir.stmt.AttrStmt:7
msgid "The value of the attribute"
msgstr ""

#: of tvm.tir.stmt.ProducerRealize:5
msgid "The bound of realize"
msgstr ""

#: of tvm.tir.stmt.ProducerRealize:9
msgid "The realize body"
msgstr ""

#: of tvm.tir.stmt.ProducerRealize:11
msgid "The storage scope associated with this realization"
msgstr ""

#: of tvm.tir.stmt.SeqStmt:3
msgid "The statements"
msgstr ""

#: of tvm.tir.stmt.IfThenElse:3
msgid "The expression"
msgstr ""

#: of tvm.tir.stmt.IfThenElse:5
msgid "The statement to execute if condition is true."
msgstr ""

#: of tvm.tir.stmt.IfThenElse:7
msgid "The statement to execute if condition is false."
msgstr ""

#: of tvm.tir.stmt.Evaluate:3
msgid "The expression to be evalued."
msgstr ""

#: of tvm.tir.stmt.Prefetch:3
msgid "The buffer to be prefetched."
msgstr ""

#: of tvm.tir.stmt.Prefetch:5
msgid "The bounds to be prefetched."
msgstr ""

#: of tvm.tir.stmt.stmt_seq:3
msgid "List of statements to be combined as sequence."
msgstr ""

#: of tvm.tir.stmt.stmt_seq:6
msgid "**stmt** -- The combined statement."
msgstr ""

#: of tvm.tir.stmt.stmt_list:6
msgid "**stmt_list** -- The unpacked list of statements"
msgstr ""

#: of tvm.tir.stmt.BufferRegion:3
msgid "The buffer of the buffer region"
msgstr ""

#: of tvm.tir.stmt.BufferRegion:5
msgid "The region array of the buffer region"
msgstr ""

#: of tvm.tir.stmt.MatchBufferRegion:3
msgid "The target buffer"
msgstr ""

#: of tvm.tir.stmt.MatchBufferRegion:5
msgid "The region of source buffer"
msgstr ""

#: of tvm.tir.stmt.Block:3
msgid "The block Variable."
msgstr ""

#: of tvm.tir.stmt.Block:5
msgid "The read buffer regions of the block."
msgstr ""

#: of tvm.tir.stmt.Block:7
msgid "The write buffer regions of the block."
msgstr ""

#: of tvm.tir.stmt.Block:9
msgid "the name_hint of the block."
msgstr ""

#: of tvm.tir.stmt.Block:11
msgid "The body of the block."
msgstr ""

#: of tvm.tir.stmt.Block:13
msgid "The init block of the reduction block"
msgstr ""

#: of tvm.tir.stmt.Block:15
msgid "The buffer allocations"
msgstr ""

#: of tvm.tir.stmt.Block:17
msgid "The subregion buffer match"
msgstr ""

#: of tvm.tir.stmt.Block:21
msgid "The location of this block in the source code."
msgstr ""

#: of tvm.tir.stmt.BlockRealize:3
msgid "The binding values of the block var."
msgstr ""

#: of tvm.tir.stmt.BlockRealize:5
msgid "The predicate of the block."
msgstr ""

#: of tvm.tir.stmt.BlockRealize:7
msgid "The block to realize"
msgstr ""

#: of tvm.tir.stmt.BlockRealize:9
msgid "The location of this block_realize in the source code."
msgstr ""

#: of tvm.tir.function.PrimFunc:3
msgid "List of input parameters to the function."
msgstr ""

#: of tvm.tir.function.PrimFunc:5
msgid "The body of the function."
msgstr ""

#: of tvm.tir.function.PrimFunc:7
msgid "The return type annotation of the function."
msgstr ""

#: of tvm.tir.function.PrimFunc:9
msgid "The buffer binding map."
msgstr ""

#: of tvm.tir.function.PrimFunc:11
msgid "Attributes of the function, can be None"
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid ""
":py:obj:`with_body <tvm.tir.PrimFunc.with_body>`\\ \\(new\\_body\\[\\, "
"span\\]\\)"
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:1
#: tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid "Create a new PrimFunc with the same set signatures but a new body."
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid ":py:obj:`specialize <tvm.tir.PrimFunc.specialize>`\\ \\(param\\_map\\)"
msgstr ""

#: of tvm.tir.function.PrimFunc.specialize:1
#: tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid "Specialize parameters of PrimFunc"
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid ""
":py:obj:`script <tvm.tir.PrimFunc.script>`\\ \\(\\[tir\\_prefix\\, "
"show\\_meta\\]\\)"
msgstr ""

#: of tvm.tir.function.PrimFunc.script:1
#: tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid "Print IRModule into TVMScript"
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:3
msgid "The new body."
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:8
msgid "**new_func** -- The created new function."
msgstr ""

#: of tvm.tir.function.PrimFunc.specialize:3
msgid "The mapping from function params to the instance"
msgstr ""

#: of tvm.tir.function.PrimFunc.specialize:8
msgid "We can define a Meta TIR function with symbolic shape:"
msgstr ""

#: of tvm.tir.function.PrimFunc.specialize:22
msgid "Then we can make it specialized with given shapes or buffers."
msgstr ""

#: of tvm.tir.function.PrimFunc.specialize:31
msgid "The specialized function:"
msgstr ""

#: of tvm.tir.function.PrimFunc.specialize:45
msgid "**func** -- The new function with parameter specialized"
msgstr ""

#: of tvm.tir.function.PrimFunc.script:3
msgid "The tir namespace prefix"
msgstr ""

#: of tvm.tir.function.PrimFunc.script:5
msgid "Whether to show meta information"
msgstr ""

#: of tvm.tir.function.PrimFunc.script:8
msgid "**script** -- The TVM Script of the PrimFunc"
msgstr ""

#: of tvm.tir.op.call_packed:3
msgid ""
"The argument to packed function can be Expr or Buffer. The argument is "
"the corresponding POD type when Expr is presented."
msgstr ""

#: of tvm.tir.op.call_packed:6
msgid ""
"When the argument is Buffer, the corresponding PackedFunc will recieve an"
" TVMArrayHandle whose content is valid during the callback period. If the"
" PackedFunc is a python callback, then the corresponding argument is "
"NDArray."
msgstr ""

#: of tvm.tir.op.call_extern:7 tvm.tir.op.call_intrin:10
#: tvm.tir.op.call_packed:10 tvm.tir.op.call_pure_extern:7 tvm.tir.op.trace:8
msgid "Positional arguments."
msgstr ""

#: of tvm.tir.op.abs:5 tvm.tir.op.all:6 tvm.tir.op.any:5
#: tvm.tir.op.call_extern:9 tvm.tir.op.call_intrin:12
#: tvm.tir.op.call_llvm_intrin:9 tvm.tir.op.call_llvm_pure_intrin:9
#: tvm.tir.op.call_packed:12 tvm.tir.op.call_pure_extern:9 tvm.tir.op.ceil:5
#: tvm.tir.op.floor:5 tvm.tir.op.isfinite:5 tvm.tir.op.isinf:5
#: tvm.tir.op.isnan:5 tvm.tir.op.max_value:5 tvm.tir.op.min_value:5
#: tvm.tir.op.nearbyint:12 tvm.tir.op.power:7 tvm.tir.op.round:5
#: tvm.tir.op.trunc:8
msgid "The location of this operator in the source code."
msgstr ""

#: of tvm.tir.op.call_extern:12 tvm.tir.op.call_intrin:15
#: tvm.tir.op.call_llvm_intrin:12 tvm.tir.op.call_llvm_pure_intrin:12
#: tvm.tir.op.call_packed:15 tvm.tir.op.call_pure_extern:12 tvm.tir.op.trace:13
msgid "**call** -- The call expression."
msgstr ""

#: of tvm.tir.op.call_packed:20
msgid ":obj:`te.extern`"
msgstr ""

#: of tvm.tir.op.call_packed:21
msgid "Create tensor with extern function call."
msgstr ""

#: of tvm.tir.op.call_intrin:3
msgid ""
"Intrinsics can be overloaded with multiple data types via the intrinsic "
"translation rule."
msgstr ""

#: of tvm.tir.op.call_extern:3 tvm.tir.op.call_intrin:6
#: tvm.tir.op.call_llvm_intrin:3 tvm.tir.op.call_llvm_pure_intrin:3
#: tvm.tir.op.call_pure_extern:3
msgid "The data type of the result."
msgstr ""

#: of tvm.tir.op.call_intrin:8
msgid "The intrinsic function name."
msgstr ""

#: of tvm.tir.op.call_extern:5 tvm.tir.op.call_pure_extern:5
msgid "The extern function name."
msgstr ""

#: of tvm.tir.op.call_llvm_intrin:5 tvm.tir.op.call_llvm_pure_intrin:5
msgid "The name of the llvm intrinsic function."
msgstr ""

#: of tvm.tir.op.call_llvm_intrin:7 tvm.tir.op.call_llvm_pure_intrin:7
msgid "Poistional arguments."
msgstr ""

#: of tvm.tir.op.ret:3
msgid ""
"The returned tir expression, whose data type is int, float or void "
"pointer."
msgstr ""

#: of tvm.tir.op.ret:6
msgid "**ret** -- The return expression"
msgstr ""

#: of tvm.tir.op.all:2
msgid "arguments"
msgstr ""

#: of tvm.tir.op.all:4 tvm.tir.op.any:3
msgid "List of symbolic boolean expressions"
msgstr ""

#: of tvm.tir.op.all:9 tvm.tir.op.any:8
msgid "**expr** -- Expression"
msgstr ""

#: of tvm.tir.op.min_value:8
msgid "**value** -- The minimum value of dtype."
msgstr ""

#: of tvm.tir.op.max_value:8
msgid "**value** -- The maximum value of dtype."
msgstr ""

#: of tvm.tir.op.trace:3
msgid ""
"The trace function allows to trace specific tensor at the runtime. The "
"tracing value should come as last argument. The trace action should be "
"specified, by default tvm.default_trace_action is used."
msgstr ""

#: of tvm.tir.op.trace:10
msgid "The name of the trace action."
msgstr ""

#: of tvm.tir.op.trace:18
msgid ":obj:`tvm.tir.call_packed`"
msgstr ""

#: of tvm.tir.op.trace:19
msgid "Creates packed function."
msgstr ""

#: of tvm.tir.op.abs:3 tvm.tir.op.acos:3 tvm.tir.op.acosh:3 tvm.tir.op.asin:3
#: tvm.tir.op.asinh:3 tvm.tir.op.atan:3 tvm.tir.op.atan2:3 tvm.tir.op.atan2:5
#: tvm.tir.op.atanh:3 tvm.tir.op.ceil:3 tvm.tir.op.copysign:3
#: tvm.tir.op.copysign:5 tvm.tir.op.cos:3 tvm.tir.op.cosh:3 tvm.tir.op.erf:3
#: tvm.tir.op.exp:3 tvm.tir.op.exp10:3 tvm.tir.op.exp2:3 tvm.tir.op.floor:3
#: tvm.tir.op.fmod:3 tvm.tir.op.fmod:5 tvm.tir.op.hypot:3 tvm.tir.op.hypot:5
#: tvm.tir.op.isfinite:3 tvm.tir.op.isinf:3 tvm.tir.op.isnan:3
#: tvm.tir.op.ldexp:3 tvm.tir.op.ldexp:5 tvm.tir.op.log:3 tvm.tir.op.log10:3
#: tvm.tir.op.log1p:3 tvm.tir.op.log2:3 tvm.tir.op.nearbyint:10
#: tvm.tir.op.nextafter:3 tvm.tir.op.nextafter:5 tvm.tir.op.popcount:3
#: tvm.tir.op.power:3 tvm.tir.op.round:3 tvm.tir.op.rsqrt:3
#: tvm.tir.op.sigmoid:3 tvm.tir.op.sin:3 tvm.tir.op.sinh:3 tvm.tir.op.sqrt:3
#: tvm.tir.op.tan:3 tvm.tir.op.tanh:3 tvm.tir.op.trunc:6
msgid "Input argument."
msgstr ""

#: of tvm.tir.op.abs:8 tvm.tir.op.acos:6 tvm.tir.op.acosh:6 tvm.tir.op.asin:6
#: tvm.tir.op.asinh:6 tvm.tir.op.atan:6 tvm.tir.op.atan2:8 tvm.tir.op.atanh:6
#: tvm.tir.op.ceil:8 tvm.tir.op.clz:7 tvm.tir.op.copysign:8 tvm.tir.op.cos:6
#: tvm.tir.op.cosh:6 tvm.tir.op.erf:6 tvm.tir.op.exp:6 tvm.tir.op.exp10:6
#: tvm.tir.op.exp2:6 tvm.tir.op.floor:8 tvm.tir.op.hypot:8
#: tvm.tir.op.isfinite:8 tvm.tir.op.isinf:8 tvm.tir.op.isnan:8
#: tvm.tir.op.ldexp:8 tvm.tir.op.log:6 tvm.tir.op.log10:6 tvm.tir.op.log1p:6
#: tvm.tir.op.log2:6 tvm.tir.op.nearbyint:15 tvm.tir.op.nextafter:8
#: tvm.tir.op.popcount:6 tvm.tir.op.q_multiply_shift:19 tvm.tir.op.round:8
#: tvm.tir.op.rsqrt:6 tvm.tir.op.sigmoid:6 tvm.tir.op.sin:6 tvm.tir.op.sinh:6
#: tvm.tir.op.sqrt:6 tvm.tir.op.tan:6 tvm.tir.op.tanh:6 tvm.tir.op.trunc:11
msgid "**y** -- The result."
msgstr ""

#: of tvm.tir.op.clz:3
msgid "Input 32 or 64 bit integer. The result is undefined if the input is 0."
msgstr ""

#: of tvm.tir.op.trunc:3
msgid ""
"The truncated value of the scalar x is the nearest integer i which is "
"closer to zero than x is."
msgstr ""

#: of tvm.tir.op.nearbyint:1
msgid ""
"Round elements of the array to the nearest integer. This intrinsic uses "
"llvm.nearbyint instead of llvm.round which is faster but will results "
"different from te.round. Notably nearbyint rounds according to the "
"rounding mode, whereas te.round (llvm.round) ignores that. For "
"differences between the two see: "
"https://en.cppreference.com/w/cpp/numeric/math/round "
"https://en.cppreference.com/w/cpp/numeric/math/nearbyint"
msgstr ""

#: of tvm.tir.op.power:5
msgid "The exponent"
msgstr ""

#: of tvm.tir.op.fmod:8 tvm.tir.op.power:10
msgid "**z** -- The result."
msgstr ""

#: of tvm.tir.op.if_then_else:3
msgid "The condition"
msgstr ""

#: of tvm.tir.op.if_then_else:5
msgid "The result expression if cond is true."
msgstr ""

#: of tvm.tir.op.if_then_else:7
msgid "The result expression if cond is false."
msgstr ""

#: of tvm.tir.op.div:7 tvm.tir.op.floordiv:7 tvm.tir.op.floormod:7
#: tvm.tir.op.if_then_else:9 tvm.tir.op.indexdiv:7 tvm.tir.op.indexmod:7
#: tvm.tir.op.truncdiv:7 tvm.tir.op.truncmod:7
msgid "The location of this operator in the source."
msgstr ""

#: of tvm.tir.op.if_then_else:12
msgid "**result** -- The result of conditional expression."
msgstr ""

#: of tvm.tir.op.if_then_else:17
msgid ""
"Unlike Select, if_then_else will not execute the branch that does not "
"satisfy the condition. You can use it to guard against out of bound "
"access. Unlike Select, if_then_else cannot be vectorized if some lanes in"
" the vector have different conditions."
msgstr ""

#: of tvm.tir.op.div:3 tvm.tir.op.indexdiv:3 tvm.tir.op.indexmod:3
msgid "The left hand operand, known to be non-negative."
msgstr ""

#: of tvm.tir.op.div:5 tvm.tir.op.indexdiv:5 tvm.tir.op.indexmod:5
msgid "The right hand operand, known to be non-negative."
msgstr ""

#: of tvm.tir.op.div:10 tvm.tir.op.floordiv:10 tvm.tir.op.floormod:10
#: tvm.tir.op.indexdiv:10 tvm.tir.op.indexmod:10 tvm.tir.op.truncdiv:10
#: tvm.tir.op.truncmod:10
msgid "**res** -- The result expression."
msgstr ""

#: of tvm.tir.op.div:13
msgid "When operands are integers, returns truncdiv(a, b, span)."
msgstr ""

#: of tvm.tir.op.indexdiv:15 tvm.tir.op.indexmod:15
msgid ""
"Use this function to split non-negative indices. This function may take "
"advantage of operands' non-negativeness."
msgstr ""

#: of tvm.tir.op.indexmod:1
msgid "Compute the remainder of indexdiv. a and b are non-negative."
msgstr ""

#: of tvm.tir.op.floordiv:3 tvm.tir.op.floormod:3 tvm.tir.op.truncdiv:3
#: tvm.tir.op.truncmod:3
msgid "The left hand operand"
msgstr ""

#: of tvm.tir.op.floordiv:5 tvm.tir.op.floormod:5 tvm.tir.op.truncdiv:5
#: tvm.tir.op.truncmod:5
msgid "The right hand operand"
msgstr ""

#: of tvm.tir.op.truncdiv:13 tvm.tir.op.truncmod:13
msgid "This is the default integer division behavior in C."
msgstr ""

#: of tvm.tir.op.comm_reducer:3
msgid "A binary function which takes two Expr as input to return a Expr."
msgstr ""

#: of tvm.tir.op.comm_reducer:5
msgid "A function which takes a type string as input to return a const Expr."
msgstr ""

#: of tvm.tir.op.comm_reducer:8
msgid ""
"**reducer** -- A function which creates a reduce expression over axis. "
"There are two ways to use it:  1. accept (expr, axis, where) to produce "
"an Reduce Expr on    specified axis; 2. simply use it with multiple "
"Exprs."
msgstr ""

#: of tvm.tir.op.comm_reducer:8
msgid ""
"**reducer** -- A function which creates a reduce expression over axis. "
"There are two ways to use it:"
msgstr ""

#: of tvm.tir.op.comm_reducer:11
msgid "accept (expr, axis, where) to produce an Reduce Expr on specified axis;"
msgstr ""

#: of tvm.tir.op.comm_reducer:13
msgid "simply use it with multiple Exprs."
msgstr ""

#: of tvm.tir.op.comm_reducer.<locals>.reducer:5
msgid "The reduction IterVar axis"
msgstr ""

#: of tvm.tir.op.comm_reducer.<locals>.reducer:7
msgid "Filtering predicate of the reduction."
msgstr ""

#: of tvm.tir.op.comm_reducer.<locals>.reducer:10
msgid "**value** -- The result value."
msgstr ""

#: of tvm.tir.op.q_multiply_shift:1
msgid ""
"Execute a multiplication between two Q-numbers x and y followed by a "
"right shift s. The mathematical expression is:"
msgstr ""

#: of tvm.tir.op.q_multiply_shift:4
msgid "out = round(x*y*2^-s)"
msgstr ""

#: of tvm.tir.op.q_multiply_shift:6
msgid ""
"More about Q-numbers here: "
"https://en.wikipedia.org/wiki/Q_(number_format) The rounding rule is to "
"the nearest value, rounding half up (i.e., round(x.1) = x and round (x.5)"
" = x+1)"
msgstr ""

#: of tvm.tir.op.q_multiply_shift:10
msgid "First Q-number"
msgstr ""

#: of tvm.tir.op.q_multiply_shift:12
msgid "Second Q-number"
msgstr ""

#: of tvm.tir.op.q_multiply_shift:14
msgid "Number of fractional bits in x and y. Needs to be > 0"
msgstr ""

#: of tvm.tir.op.q_multiply_shift:16
msgid "Integer shift"
msgstr ""

#: of tvm.tir.schedule.block_scope.StmtSRef:3
msgid ""
"Glossary - Block sref: An StmtSref that points to a TensorIR block. - "
"Loop sref: An StmtSRef that points to a TensorIR for loop. - Parent sref:"
" The parent sref of an sref is the block/loop sref that points to its "
"closest schedulable statement of its ancestors on the TensorIR AST. - "
"Root sref: Sref to the root block. Every sref has exactly one parent sref"
" except for root sref. - Sref tree: The parent-children-relationship of "
"srefs that forms a tree, uniquely determined by the TensorIR AST."
msgstr ""

#: of tvm.tir.schedule.block_scope.StmtSRef:1
#: tvm.tir.schedule.schedule.Schedule:1
msgid "**Attributes:**"
msgstr ""

#: of tvm.tir.schedule.block_scope.StmtSRef:1:<autosummary>:1
msgid ":py:obj:`stmt <tvm.tir.StmtSRef.stmt>`\\"
msgstr ""

#: of tvm.tir.StmtSRef.stmt:1
#: tvm.tir.schedule.block_scope.StmtSRef:1:<autosummary>:1
msgid "The block/for stmt the object refers to"
msgstr ""

#: of tvm.tir.schedule.block_scope.StmtSRef:1:<autosummary>:1
msgid ":py:obj:`parent <tvm.tir.StmtSRef.parent>`\\"
msgstr ""

#: of tvm.tir.StmtSRef.parent:1
#: tvm.tir.schedule.block_scope.StmtSRef:1:<autosummary>:1
msgid "The parent sref"
msgstr ""

#: of tvm.tir.StmtSRef.stmt:1:<autosummary>:1
msgid ":py:obj:`inline_mark <tvm.tir.StmtSRef.inline_mark>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.StmtSRef.stmt:1:<autosummary>:1
#: tvm.tir.schedule.block_scope.StmtSRef.inline_mark:1
msgid ""
"A special StmtSRef, which doesn't point to any stmt in the AST, only "
"serving as a \"mark\" to hint compute-at to do the work of compute-inline"
msgstr ""

#: of tvm.tir.StmtSRef.stmt:1:<autosummary>:1
msgid ":py:obj:`root_mark <tvm.tir.StmtSRef.root_mark>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.StmtSRef.stmt:1:<autosummary>:1
#: tvm.tir.schedule.block_scope.StmtSRef.root_mark:1
msgid ""
"A special StmtSRef, which doesn't point to any stmt in the AST, only "
"serving as a \"mark\" to hint compute-at to do nothing"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope:4
msgid "Glossary:"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope:6
msgid ""
"Block scope: A contiguous subtree of the sref tree, rooted at each block "
"sref, whose components are:"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope:9
msgid "scope root: a block sref"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope:10
msgid "internal srefs: loop srefs"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope:11
msgid "scope leaves: block srefs"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope:13
msgid ""
"Child block: The scope leaf blocks under the scope root or a specific "
"internal sref"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src:1:<autosummary>:1
msgid ""
":py:obj:`get_deps_by_src <tvm.tir.BlockScope.get_deps_by_src>`\\ "
"\\(block\\)"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src:1
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src:1:<autosummary>:1
msgid "Get all dependencies whose `src` is the target`block`."
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src:1:<autosummary>:1
msgid ""
":py:obj:`get_deps_by_dst <tvm.tir.BlockScope.get_deps_by_dst>`\\ "
"\\(block\\)"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope.get_deps_by_dst:1
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src:1:<autosummary>:1
msgid "Get all dependencies whose `dst` is the target `block`."
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope.get_deps_by_dst:3
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src:3
msgid "The queried block"
msgstr ""

#: of tvm.tir.schedule.block_scope.BlockScope.get_deps_by_dst:6
#: tvm.tir.schedule.block_scope.BlockScope.get_deps_by_src:6
msgid "**blocks** -- The dependencies"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState:4
msgid ""
"The data structure contains the following information 1) The AST being "
"scheduled (mod) 2) The sref tree of schedulable statements (indicated by "
"the srefs) 3) The dependency information of each block scope (block_info)"
" 4) A reverse mapping from the AST nodes to that in the sref tree "
"(get_sref) 5) A debug flag, if set, extra checking is enabled "
"(debug_mask)"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState:11
msgid "The AST of the module being scheduled"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState:13
msgid ""
"Do extra correctness checking after the object construction and each time"
" after calling the Replace method."
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_sref:1:<autosummary>:1
msgid ":py:obj:`get_sref <tvm.tir.ScheduleState.get_sref>`\\ \\(stmt\\)"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_sref:1
#: tvm.tir.schedule.state.ScheduleState.get_sref:1:<autosummary>:1
msgid "Return the corresponding sref that points to the stmt"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_sref:1:<autosummary>:1
msgid ""
":py:obj:`get_block_scope <tvm.tir.ScheduleState.get_block_scope>`\\ "
"\\(block\\_sref\\)"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_block_scope:1
#: tvm.tir.schedule.state.ScheduleState.get_sref:1:<autosummary>:1
msgid "Get the BlockScope correpsonding to the block sref"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_sref:1:<autosummary>:1
msgid ""
":py:obj:`replace <tvm.tir.ScheduleState.replace>`\\ \\(src\\_sref\\, "
"tgt\\_stmt\\[\\, block\\_sref\\_reuse\\]\\)"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_sref:1:<autosummary>:1
msgid ""
"Replace the part of the AST, as being pointed to by `src_sref`, with a "
"specific statement `tgt_stmt`, and maintain the sref tree accordingly."
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_sref:3
msgid "The schedulable statement in the TensorIR to be retrieved for its sref"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_block_scope:6
#: tvm.tir.schedule.state.ScheduleState.get_sref:6
msgid "**sref** -- The corresponding sref"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.get_block_scope:3
msgid "The block sref to be retrieved"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.replace:1
msgid ""
"Replace the part of the AST, as being pointed to by `src_sref`, with a "
"specific statement `tgt_stmt`, and maintain the sref tree accordingly. "
"Replace will try to perform copy on write as much as possible when the "
"ScheduleState holds the only copy to the IRModule and IR nodes."
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.replace:6
msgid ""
"Only 3 types of replacements are allowed: from `src_sref->stmt` to "
"`tgt_stmt`. 1) Block -> Block 2) Loop -> Loop 3) Loop -> BlockRealize"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.replace:11
msgid "The sref to the statement to be replaced in the TensorIR AST"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.replace:13
msgid "The statement to be replaced to"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.replace:15
msgid ""
"Maps an old block (to be replaced in the subtree under `src_sref->stmt`) "
"to a new block (replaced to, in the subtree under `tgt_stmt`), and "
"enforces reuse of srefs between them (rather than create new srefs) i.e. "
"after being replaced, the sref that points to the old block will point to"
" the new one"
msgstr ""

#: of tvm.tir.schedule.state.ScheduleState.replace:21
msgid ""
"The reuse of loop srefs are detected automatically according to the reuse"
" of loop vars."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule:3
msgid ""
"A schedule is a set of transformations that change the order of "
"computation but preserve the semantics of computation. Some example of "
"schedules: 1) Split a loop into two; 2) Reorder two loops; 3) Inline the "
"computation of a specific buffer into its consumer"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule:9
msgid ""
"The schedule class stores auxiliary information to schedule correctly and"
" efficiently."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule:11
msgid ""
"Link to tutorial: "
"https://tvm.apache.org/docs/tutorials/language/schedule_primitives.html"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule:1:<autosummary>:1
msgid ":py:obj:`mod <tvm.tir.Schedule.mod>`\\"
msgstr ""

#: of tvm.tir.Schedule.mod:1
#: tvm.tir.schedule.schedule.Schedule:1:<autosummary>:1
msgid "Returns the AST of the module being scheduled"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule:1:<autosummary>:1
msgid ":py:obj:`state <tvm.tir.Schedule.state>`\\"
msgstr ""

#: of tvm.tir.Schedule.state:1
#: tvm.tir.schedule.schedule.Schedule:1:<autosummary>:1
msgid "Returns the ScheduleState in the current schedule class"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule:1:<autosummary>:1
msgid ":py:obj:`trace <tvm.tir.Schedule.trace>`\\"
msgstr ""

#: of tvm.tir.Schedule.trace:1
#: tvm.tir.schedule.schedule.Schedule:1:<autosummary>:1
msgid "Returns the internally maintained trace of scheduling program execution"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`copy <tvm.tir.Schedule.copy>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.copy:1
msgid ""
"Returns a copy of the schedule, including both the state and the symbol "
"table, * guaranteeing that * 1) SRef tree is completely reconstructed; * "
"2) The IRModule being scheduled is untouched; * 3) All the random "
"variables are valid in the copy, pointing to the corresponding sref * "
"reconstructed"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`seed <tvm.tir.Schedule.seed>`\\ \\(seed\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.seed:1
msgid "Seed the randomness"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`fork_seed <tvm.tir.Schedule.fork_seed>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.fork_seed:1
msgid "Returns a forked random state as seed for new schedules"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`show <tvm.tir.Schedule.show>`\\ \\(rand\\_var\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.show:1
msgid ""
"Returns a string representation of the value that the random variable "
"evaluates to"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`get <tvm.tir.Schedule.get>`\\ \\(rand\\_var\\_or\\_sref\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.get:1
msgid ""
"Returns: - the corresponding Block that a BlockRV evaluates to; - the "
"corresponding For that a LoopRV evaluates to; - the corresponding integer"
" that a ExprRV evaluates to; - the corresponding Block that a block sref "
"points to; - the corresponding For that a loop sref points to;"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`get_sref <tvm.tir.Schedule.get_sref>`\\ "
"\\(rand\\_var\\_or\\_stmt\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.get_sref:1
msgid ""
"Returns the corresponding sref to the given 1) LoopRV 2) BlockRV 3) Block"
" 4) For"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`remove_rv <tvm.tir.Schedule.remove_rv>`\\ \\(rand\\_var\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.remove_rv:1
msgid "Remove a random variable from the symbol table"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`sample_categorical <tvm.tir.Schedule.sample_categorical>`\\ "
"\\(candidates\\, probs\\[\\, decision\\]\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.sample_categorical:1
msgid "Sample an integer given the probability distribution"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`sample_perfect_tile <tvm.tir.Schedule.sample_perfect_tile>`\\ "
"\\(loop\\, n\\[\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.sample_perfect_tile:1
msgid "Sample the factors to perfect tile a specific loop"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`get_block <tvm.tir.Schedule.get_block>`\\ \\(name\\[\\, "
"func\\_name\\]\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.get_block:1
msgid "Retrieve a block in a specific function with its name"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`get_loops <tvm.tir.Schedule.get_loops>`\\ \\(block\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.get_loops:1
msgid "Get the parent loops of the block in its scope, from outer to inner"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`get_child_blocks <tvm.tir.Schedule.get_child_blocks>`\\ "
"\\(block\\_or\\_loop\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.get_child_blocks:1
msgid "Get the leaf blocks of a specific block/loop"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`get_producers <tvm.tir.Schedule.get_producers>`\\ \\(block\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.get_producers:1
msgid "Get the producers of a specific block"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`get_consumers <tvm.tir.Schedule.get_consumers>`\\ \\(block\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.get_consumers:1
msgid "Get the consumers of a specific block"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`fuse <tvm.tir.Schedule.fuse>`\\ \\(\\*loops\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Fuse a list of consecutive loops into one."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`split <tvm.tir.Schedule.split>`\\ \\(loop\\, factors\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Split a loop into a list of consecutive loops."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`reorder <tvm.tir.Schedule.reorder>`\\ \\(\\*ordered\\_loops\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Reorder a list of loops."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`parallel <tvm.tir.Schedule.parallel>`\\ \\(loop\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Parallelize the input loop."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`vectorize <tvm.tir.Schedule.vectorize>`\\ \\(loop\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Vectorize the input loop."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`bind <tvm.tir.Schedule.bind>`\\ \\(loop\\, thread\\_axis\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Bind the input loop to the given thread axis."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`unroll <tvm.tir.Schedule.unroll>`\\ \\(loop\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Unroll the input loop."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`cache_read <tvm.tir.Schedule.cache_read>`\\ \\(block\\, "
"read\\_buffer\\_index\\, ...\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Create a block that reads a buffer region into a read cache."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`cache_write <tvm.tir.Schedule.cache_write>`\\ \\(block\\, "
"write\\_buffer\\_index\\, ...\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Create a block that reads a buffer region into a write cache."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`compute_at <tvm.tir.Schedule.compute_at>`\\ \\(block\\, "
"loop\\[\\, preserve\\_unit\\_loops\\]\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Compute-At."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`reverse_compute_at <tvm.tir.Schedule.reverse_compute_at>`\\ "
"\\(block\\, loop\\[\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Reverse-Compute-At."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`compute_inline <tvm.tir.Schedule.compute_inline>`\\ \\(block\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Inline a block into its consumer(s)."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`reverse_compute_inline "
"<tvm.tir.Schedule.reverse_compute_inline>`\\ \\(block\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid "Inline a block into its only producer."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`decompose_reduction <tvm.tir.Schedule.decompose_reduction>`\\ "
"\\(block\\, loop\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.decompose_reduction:1
msgid "Decompose a reduction block into two separate blocks."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`rfactor <tvm.tir.Schedule.rfactor>`\\ \\(loop\\, factor\\_axis\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.rfactor:1
msgid "Factorize an associative reduction block by the specified loop."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
":py:obj:`storage_align <tvm.tir.Schedule.storage_align>`\\ \\(block\\, "
"buffer\\_index\\, axis\\, ...\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ""
"Set alignment requirement for specific dimension such that stride[axis] "
"== k * factor + offset for some k."
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
msgid ":py:obj:`enter_postproc <tvm.tir.Schedule.enter_postproc>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.Schedule.mod:1:<autosummary>:1
#: tvm.tir.schedule.schedule.Schedule.enter_postproc:1
msgid "A no-op that marks the start of postprocessing phase of scheduling"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.copy:8
msgid "**copy** -- A new copy of the schedule"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.seed:3
msgid "The new random seed, -1 if use device random, otherwise non-negative"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.fork_seed:3
msgid ""
"**seed** -- The forked random state, not the same as the current random "
"state"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.show:3
msgid "The random variable to be evaluated"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.show:6
msgid "**str_repr** -- The string representation"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get:8
#: tvm.tir.schedule.schedule.Schedule.get_sref:7
msgid "The random variable / sref to be evaluated"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get:11
#: tvm.tir.schedule.schedule.Schedule.get_sref:10
msgid "**result** -- The corresponding result"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.remove_rv:3
msgid "The random variable to be removed"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_categorical:3
msgid "The candidates to be sampled from"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_categorical:5
msgid "The probability of each candidate"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_categorical:7
#: tvm.tir.schedule.schedule.Schedule.sample_perfect_tile:9
msgid "The sampling decision, if any"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_categorical:10
msgid "**result** -- The random variable sampled from candidates"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_perfect_tile:3
msgid "The loop to be tiled"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_perfect_tile:5
msgid "The number of tiles to be sampled"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_perfect_tile:7
msgid "The maximum tile size allowed to be sampled in the innermost loop"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.sample_perfect_tile:12
msgid "**result** -- A list of length `n`, the random perfect tile sizes sampled"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_block:3
msgid "The name of the block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_block:5
msgid "The name of the function"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_block:8
msgid ""
"**block** -- The block retrieved IndexError is raised if 0 or multiple "
"blocks exist with the specific name."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_loops:3
msgid "The query block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_loops:6
msgid ""
"**loops** -- A list of loops above the given block in its scope, from "
"outer to inner"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_child_blocks:3
msgid "The query block/loop"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_child_blocks:6
msgid "**blocks** -- A list of leaf blocks inside a specific block/loop"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_consumers:3
#: tvm.tir.schedule.schedule.Schedule.get_producers:3
msgid "The block in the query"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_producers:6
msgid "**producers** -- A list of producers of the given block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.get_consumers:6
msgid "**consumers** -- A list of consumers of the given block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.fuse:1
msgid ""
"Fuse a list of consecutive loops into one. It requires: 1) The loops "
"can't have annotations or thread bindings. 2) The (i+1)-th loop must be "
"the only child of the i-th loop. 3) All loops must start with 0. 4) The "
"domain of a loop to be fused cannot depend on another loop to be fused."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.fuse:7
msgid "The loops to be fused"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.fuse:10
msgid "**fused_loop** -- The new loop after fusion"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.fuse:15
msgid "Before applying fuse, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.fuse:28
msgid "Create the schedule and do fuse:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.fuse:37
msgid "After applying fuse, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.split:1
msgid ""
"Split a loop into a list of consecutive loops. It requires: 1) The loop "
"can't have annotation or thread binding. 2) The loop must start with 0. "
"Predicates may be added to ensure the total loop numbers keeps unchanged."
" In `factors`, at most one of the factors can be None, which will be "
"automatically inferred."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.split:8
msgid "The loop to be split"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.split:10
msgid ""
"The splitting factors Potential inputs are: - None - ExprRV - Nonnegative"
" constant integers"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.split:17
msgid "**split_loops** -- The new loops after split"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.split:22
msgid "Before split, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.split:35
msgid "Create the schedule and do split:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.split:44
msgid "After applying split, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reorder:1
msgid ""
"Reorder a list of loops. It doesn't require the loops to be consecutive. "
"It requires: 1) The loops are in the same chain. That means: the loops "
"can be ordered to [l_1, l_2, ... , l_n] where l_i is an ancestor of "
"l_{i+1} and there are only single-branch loops between l_1 and l_n (which"
" also indicates they are under the same scope). 2) After reordering, the "
"domain of an outer loop cannot depend on any of the inner loops. 3) For "
"every block under the loop nests, its block binding must be affine, and "
"the block variables must be either data parallel or reduction. 4) No "
"duplicated loops are allowed in the arguments."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reorder:11
msgid "The loops in the new order"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reorder:16
msgid "Before reorder, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reorder:29
msgid "Create the schedule and do reorder:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reorder:38
msgid "After applying reorder, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.parallel:1
msgid ""
"Parallelize the input loop. It requires: 1) The scope block that the loop"
" is in should have stage-pipeline property 2) All the blocks under the "
"loop are complete blocks or reduction blocks, and have affine bindings 3)"
" For each block under the loop, the loop can only be contained in data-"
"parallel block iters' bindings"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.parallel:8
msgid "The loop to be parallelized"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.parallel:13
msgid "Before parallel, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.parallel:26
msgid "Create the schedule and do parallel:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.parallel:34
msgid "After applying parallel, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.vectorize:1
msgid ""
"Vectorize the input loop. It requires: 1) The scope block that the loop "
"is in should have stage-pipeline property 2) All the blocks under the "
"loop are complete blocks or reduction blocks, and have affine bindings 3)"
" For each block under the loop, the loop can only be contained in data-"
"parallel block iters' bindings"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.vectorize:8
msgid "The loop to be vectorized"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.vectorize:13
msgid "Before vectorize, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.vectorize:26
msgid "Create the schedule and do vectorize:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.vectorize:34
msgid "After applying vectorize, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.bind:1
msgid ""
"Bind the input loop to the given thread axis. It requires: 1) The scope "
"block that the loop is in should have stage-pipeline property 2) All the "
"blocks under the loop are complete blocks or reduction blocks, and have "
"affine bindings 3) For each block under the loop, if the thread axis "
"starts with \"threadIdx`, the loop can only be contained in data-parallel"
" block iter and reduction block iters' bindings. Otherwise the loop can "
"only be contained in data-parallel block iters' bindings"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.bind:9
msgid "The loop to be bound to the thread axis"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.bind:11
msgid ""
"The thread axis to be bound to the loop. Possible candidates: - "
"blockIdx.x/y/z - threadIdx.x/y/z - vthread.x/y/z - vthread (It is a "
"legacy behavior that will be deprecated. Please use `vthread.x/y/z` "
"instead.)"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.bind:21
msgid "Before bind, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.bind:34
msgid "Create the schedule and do bind:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.bind:43
msgid "After applying bind, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.unroll:1
msgid "Unroll the input loop. It requires nothing"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.unroll:3
msgid "The loop to be unrolled"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.unroll:8
msgid "Before unroll, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.unroll:21
msgid "Create the schedule and do unroll:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.unroll:29
msgid "After applying unroll, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:1
msgid "Create a block that reads a buffer region into a read cache. It requires:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:3
msgid "There is at most one block who write the buffer in the scope."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:5
#: tvm.tir.schedule.schedule.Schedule.cache_write:5
msgid "The scope block have stage-pipeline property."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:7
msgid "The consumer block of the target buffer."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:9
msgid "The index of the buffer in block's read region."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:11
#: tvm.tir.schedule.schedule.Schedule.cache_write:11
#: tvm.tir.transform.transform.ThreadSync:3
msgid "The target storage scope."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:14
#: tvm.tir.schedule.schedule.Schedule.cache_write:14
msgid "**cached_block** -- The block of the cache stage"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:19
msgid "Before cache_read, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:32
msgid "Create the schedule and cache_read:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_read:41
msgid "After applying cache_read, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_write:1
msgid "Create a block that reads a buffer region into a write cache. It requires:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_write:3
msgid "There is only one block who write the buffer in the scope."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_write:7
msgid "The producer block of the target buffer."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_write:9
#: tvm.tir.schedule.schedule.Schedule.storage_align:8
msgid "The index of the buffer in block's write region."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_write:19
msgid "Before cache_write, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_write:32
msgid "Create the schedule and cache_write:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.cache_write:41
msgid "After applying cache_write, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:1
msgid ""
"Compute-At. Move a producer block under the specific loop, and regenerate"
" the loops induced by the block so that the buffer region produced by the"
" producer block could cover those regions consumed by its consumer blocks"
" under the given loop. It requires:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:5
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at:5
msgid ""
"`block` and `loop` are under the same scope, `loop` is not the ancestor "
"of `block`"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:7
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at:7
msgid "The scope block has stage-pipeline property"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:9
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at:9
msgid ""
"3) The subtree of the scope block, where the given block is in, satisfies"
" the compact dataflow condition. i.e. all the blocks in the scope block's"
" subtree must be either complete block or reduction block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:13
msgid ""
"4) The block is not an output block with regard to the scope block, i.e. "
"the buffers written by the block are allocated under the scope block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:16
msgid "All the consumers of the block are under the given loop"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:18
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at:15
msgid "The block to be moved"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:20
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at:17
msgid "The loop where the block to be moved under"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:22
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_at:19
msgid "Whether to keep the trivial loops whose extents are 1"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:27
msgid "Before compute-at, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:45
msgid "Create the schedule and do compute-at:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_at:55
msgid "After applying compute-at, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_at:1
msgid ""
"Reverse-Compute-At. Move a consumer block under the specific loop, and "
"regenerate the loops induced by the block so that the buffer region "
"consumed by the consumer block could cover those regions produced by its "
"producer blocks under the given loop. It requires:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_at:13
msgid "All the producers of the block are under the given loop"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_at:24
msgid "Before reverse-compute-at, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_at:42
msgid "Create the schedule and do reverse-compute-at:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_at:52
msgid "After applying reverse-compute-at, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:1
msgid "Inline a block into its consumer(s). It requires:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:3
msgid "The block is a complete non-root block, which only produces one buffer"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:5
#: tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:5
msgid "The block must not be the only leaf in the scope."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:7
msgid ""
"The body of the block must be a BufferStore statement in the form of, "
"``A[i, j, k, ...] = ...`` where the indices of the LHS are all distinct "
"atomic variables, and no variables other than those indexing variables "
"are allowed in the statement."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:13
msgid "The block to be inlined to its consumer(s)"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:18
msgid "Before compute-inline, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:36
msgid "Create the schedule and do compute-inline:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.compute_inline:44
msgid "After applying compute-inline, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:1
msgid "Inline a block into its only producer. It requires:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:3
msgid ""
"The block is a complete non-root block, which only produces and consumes "
"one buffer"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:7
msgid ""
"The only producer of the block is a read-after-write producer and a "
"complete non-root block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:10
msgid ""
"The body of the block must be a BufferStore statement in the form of, "
"``B[f(i, j, k, ...)] = g(i, j, k, A[i, j, k, ...] ...)`` where the "
"indices of each `BufferLoad` on the RHS are all distinct atomic "
"variables, and no variables other than those indexing variables are "
"allowed in the statement."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:16
msgid "The block to be inlined to its producer"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:21
msgid "Before reverse-compute-inline, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:39
msgid "Create the schedule and do reverse-compute-inline:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.reverse_compute_inline:47
msgid "After applying reverse-compute-inline, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:3
msgid ""
"The init block, which is translated from the init statement of the "
"reduction block;"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:5
msgid "The update block, which is the original block without init statement."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:7
msgid "The init block is inserted right before the given loop."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:9
msgid "The schedule primitive requires:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:11
msgid "The input block is a reduction block."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:13
msgid "The input loop is the ancestor of the block."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:15
msgid ""
"The input loop is not lower than all the loops related to reduce block "
"var."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:17
msgid "The reduction block to be decomposed"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:19
msgid "The loop above which the init block is inserted before."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:22
msgid "**init_block** -- The init block"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:27
msgid "Before decompose-reduction, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:42
msgid "Create the schedule and do decompose-reduction with specified loop:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.decompose_reduction:52
msgid "After applying decompose-reduction, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:3
msgid ""
"An associative reduction cannot be parallelized directly, because it "
"leads to potential race condition during accumulation. Alternatively, the"
" reduction could be factorized on a loop with the following steps: - Step"
" 1: evenly slice the reduction into `n` separate chunks, where `n` is the"
" loop extent - Step 2: compute the chunks separately and write the result"
" into `n` intermediate buffers; - Step 3: accumulate the `n` separate "
"buffer into the result buffer. Note that the Step 2 above introduces "
"opportunities for parallelization."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:11
msgid ""
"RFactor is a schedule primitive that implements the transformation "
"described above: Given a block that writes to buffer `B`, it factorizes a"
" loop of extent `n`."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:14
msgid "For example, the pseudocode below accumulates `B[i] = sum(A[i, : , : ])`:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:23
msgid ""
"Suppose RFactor is applied on the innermost loop `k` and `factor_axis = "
"1`. RFactor then creates an intermediate buffer and two blocks."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:26
msgid ""
"1. The intermediate buffer, or \"rf-buffer\" is a buffer of rank `ndim(B)"
" + 1` and size `size(B) * n`, whose shape expands from `shape(B)` by "
"adding an axis of `n` at the position specified by `factor_axis`. For "
"example,"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:30
msgid "shape(B) = [1, 2, 3], factor_axis = 0  => shape(B_rf) = [n, 1, 2, 3]"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:31
msgid "shape(B) = [1, 2, 3], factor_axis = 1  => shape(B_rf) = [1, n, 2, 3]"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:32
msgid "shape(B) = [1, 2, 3], factor_axis = 2  => shape(B_rf) = [1, 2, n, 3]"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:33
msgid "shape(B) = [1, 2, 3], factor_axis = 3  => shape(B_rf) = [1, 2, 3, n]"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:35
msgid ""
"2. The rfactor block, or \"rf-block\", is a block that writes to the `rf-"
"buffer` without accumulating over the loop `k`, i.e. the loop `k` is "
"converted from a reduction loop to a data parallel loop. In our example, "
"the rf-block is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:48
msgid ""
"3. The write-back block, or `wb-block`, is a block that accumulates the "
"rf-buffer into the result buffer. All the reduction loops are removed "
"except the loop `k` for accumulation. In our example, the wb-block is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:60
msgid "The loop outside block for which we want to do rfactor"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:62
msgid ""
"The position where the new dimension is placed in the new introduced "
"rfactor buffer"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:65
msgid ""
"**rf_block** -- The block which computes partial results over each slices"
" (i.e., the first block as described in the above illustration)"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:71
msgid "Before rfactor, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:86
msgid "Create the schedule and do rfactor:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:95
#: tvm.tir.schedule.schedule.Schedule.storage_align:45
msgid "After applying rfactor, the IR becomes:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.rfactor:119
msgid ""
"Rfactor requires: 1) `loop` has only one child block, and it is a "
"reduction block; 2) `loop` is a reduction loop, i.e. the loop variable is"
" bound to only reduction variables in the block binding; 3) `loop` is not"
" parallelized, vectorized, unrolled or bound to any thread axis; 4) The "
"block scope that `loop` is in is a staged-pipeline; 5) The outermost loop"
" outside the reduction block should has the reduction block as its first "
"child block; 6) The outermost reduction loop should have only one child "
"block; 7) An unary extent loop that is not bound to any reduction or data"
" parallel variables in the block binding should not appear under some "
"reduction loop; 8) The reduction block should write to only one buffer, "
"and its init and body are both simple `BufferStore`s, and the pattern is "
"registered as an associative reducer. The pre-defined patterns include: "
"plus, multiplication, min and max; 9) Each of the loops on top of the "
"block cannot be bound to a data parallel and a reduction block binding at"
" the same time; 10) `factor_axis` should be in range `[-ndim(B) - 1, "
"ndim(B)]`, where `B` is the buffer that the reduction block writes to. "
"Negative indexing is normalized according to numpy convention."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:1
msgid ""
"Set alignment requirement for specific dimension such that stride[axis] "
"== k * factor + offset for some k. This is useful to set memory layout "
"for more friendly memory access pattern. For example, we can set "
"alignment to be factor=2, offset=1 to avoid bank conflict for thread "
"access on higher dimension in GPU shared memory."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:6
msgid "The producer block of the buffer."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:10
msgid "The dimension to be specified for alignment."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:12
msgid "The factor multiple of alignment."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:14
msgid "The required offset factor."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:19
msgid "Before storage_align, in TensorIR, the IR is:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:37
msgid "Create the schedule and do storage_align:"
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:64
msgid "After lowering passes, buffer B will have strides as [129, 1]."
msgstr ""

#: of tvm.tir.schedule.schedule.Schedule.storage_align:66
msgid ""
"Storage_align requires the buffer to be an intermediate buffer defined "
"via `alloc_buffer`."
msgstr ""

#: ../../_staging/reference/api/python/tir.rst:30
msgid "tvm.tir.transform"
msgstr ""

#: of tvm.tir.transform:1
msgid "Namespace of all TIR transformations"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`prim_func_pass <tvm.tir.transform.prim_func_pass>`\\ "
"\\(\\[pass\\_func\\, opt\\_level\\, name\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Decorate a function pass."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`Apply <tvm.tir.transform.Apply>`\\ \\(ftransform\\)"
msgstr ""

#: of tvm.tir.transform.transform.Apply:1 tvm.tir.transform:1:<autosummary>:1
msgid "Apply ftransform to each function in the Module."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`BF16CastElimination <tvm.tir.transform.BF16CastElimination>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
"Eliminate verbose casting between fp32 and bf16 Checks if the AST has the"
" pattern: castto32(castto16(some_fp32_op(...))) The verbose casting is "
"generated by BF16Promote for multiple bf16 Ops in a row."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`BF16Legalize <tvm.tir.transform.BF16Legalize>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid "Legalize bf16 typed Ops."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`BF16Promote <tvm.tir.transform.BF16Promote>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid "Promote bf16 to fp32."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`BF16TypeLowering <tvm.tir.transform.BF16TypeLowering>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid "Replace all bf16 type with uint16."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`CoProcSync <tvm.tir.transform.CoProcSync>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.CoProcSync:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Detect and insert sync points to co-processor."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`CombineContextCall <tvm.tir.transform.CombineContextCall>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.CombineContextCall:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Combine context calls in the host function."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`CompactBufferAllocation "
"<tvm.tir.transform.CompactBufferAllocation>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid "Compact the buffer access region."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`ConvertBlocksToOpaque "
"<tvm.tir.transform.ConvertBlocksToOpaque>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.ConvertBlocksToOpaque:1
#: tvm.tir.transform:1:<autosummary>:1
msgid ""
"Substitute all the block vars with the PrimExprs they are bound to, "
"indicated by the corresponding iter_values in BlockRealize, and then "
"convert the blocks into opaque ones by removing all the iter_values in "
"BlockRealize and iter_vars in Block."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`ConvertForLoopsToSerial "
"<tvm.tir.transform.ConvertForLoopsToSerial>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.ConvertForLoopsToSerial:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Convert Parallel For Loops to Serial For Loops."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`DecorateDeviceScope <tvm.tir.transform.DecorateDeviceScope>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.DecorateDeviceScope:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Decorate all the function's body as device function."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`Filter <tvm.tir.transform.Filter>`\\ \\(fcond\\)"
msgstr ""

#: of tvm.tir.transform.transform.Filter:1 tvm.tir.transform:1:<autosummary>:1
msgid "Filter functions by the calling convention attribute."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`FlattenBuffer <tvm.tir.transform.FlattenBuffer>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
"Flatten the multi-dimensional BufferLoad and BufferStore to single "
"dimensional Load/Store."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`HoistIfThenElse <tvm.tir.transform.HoistIfThenElse>`\\ "
"\\(\\[variant\\]\\)"
msgstr ""

#: of tvm.tir.transform.transform.HoistIfThenElse:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Hoist loop-invariant IfThenElse nodes to outside the eligible loops."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`InferFragment <tvm.tir.transform.InferFragment>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.InferFragment:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Infer the TensorCore fragment infomation using tensor intrinsics."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`InjectCopyIntrin <tvm.tir.transform.InjectCopyIntrin>`\\ "
"\\(pragma\\_key\\, fintrin\\)"
msgstr ""

#: of tvm.tir.transform.transform.InjectCopyIntrin:1
#: tvm.tir.transform.transform.InjectVirtualThread:1
#: tvm.tir.transform.transform.LoopPartition:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Inject virtual thread loops."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`InjectDoubleBuffer <tvm.tir.transform.InjectDoubleBuffer>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.InjectDoubleBuffer:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Inject double buffer statements."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`InjectPrefetch <tvm.tir.transform.InjectPrefetch>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.InjectPrefetch:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Inject prefetch instructions into stmt."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`InjectVirtualThread <tvm.tir.transform.InjectVirtualThread>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`InstrumentBoundCheckers "
"<tvm.tir.transform.InstrumentBoundCheckers>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.InstrumentBoundCheckers:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Instruments bound checkers."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`LegalizePackedCalls <tvm.tir.transform.LegalizePackedCalls>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LegalizePackedCalls:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Legalize packed calls to have its arguments wrapped in TVMValues"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`LiftAttrScope <tvm.tir.transform.LiftAttrScope>`\\ "
"\\(attr\\_key\\)"
msgstr ""

#: of tvm.tir.transform.transform.LiftAttrScope:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lift common attrs with attr_key to outer scope."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`LoopPartition <tvm.tir.transform.LoopPartition>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`LowerCustomDatatypes <tvm.tir.transform.LowerCustomDatatypes>`\\"
" \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LowerCustomDatatypes:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower custom datatypes."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`LowerDeviceStorageAccessInfo "
"<tvm.tir.transform.LowerDeviceStorageAccessInfo>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LowerDeviceStorageAccessInfo:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower attached storage access information on device."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`LowerInitBlock <tvm.tir.transform.LowerInitBlock>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LowerInitBlock:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower block init stmt into IfThenElse statements."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`LowerIntrin <tvm.tir.transform.LowerIntrin>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LowerIntrin:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower target specific intrinsic calls."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`LowerMatchBuffer <tvm.tir.transform.LowerMatchBuffer>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid "Remove match buffers inside the block."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`LowerTVMBuiltin <tvm.tir.transform.LowerTVMBuiltin>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LowerTVMBuiltin:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower tvm builtin intrinsics."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`LowerThreadAllreduce <tvm.tir.transform.LowerThreadAllreduce>`\\"
" \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LowerThreadAllreduce:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower cross thread alleduce."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`LowerWarpMemory <tvm.tir.transform.LowerWarpMemory>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.LowerWarpMemory:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower warp memory access to low-level device related function calls."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`MakePackedAPI <tvm.tir.transform.MakePackedAPI>`\\ "
"\\(\\[num\\_unpacked\\_params\\]\\)"
msgstr ""

#: of tvm.tir.transform.transform.MakePackedAPI:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Transform the PrimFuncs in the module to a packed func API."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`MakeUnpackedAPI <tvm.tir.transform.MakeUnpackedAPI>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.MakeUnpackedAPI:1
#: tvm.tir.transform:1:<autosummary>:1
msgid ""
"Transform the PrimFuncs in the module to a C API compatible with internal"
" calls."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`MergeDynamicSharedMemoryAllocations "
"<tvm.tir.transform.MergeDynamicSharedMemoryAllocations>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.MergeDynamicSharedMemoryAllocations:1
#: tvm.tir.transform:1:<autosummary>:1
msgid ""
"This pass merges multiple TIR-level dynamic shared memory allocations "
"into one allocation."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`NarrowDataType <tvm.tir.transform.NarrowDataType>`\\ "
"\\(target\\_bits\\)"
msgstr ""

#: of tvm.tir.transform.transform.NarrowDataType:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Narrow down PrimExpr datatype in stmt to target_bits."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`PlanAndUpdateBufferAllocationLocation "
"<tvm.tir.transform.PlanAndUpdateBufferAllocationLocation>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
"Locate the buffer allocation to the exact position (usually is the lca of"
" buffer access)."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`RemoveNoOp <tvm.tir.transform.RemoveNoOp>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.RemoveNoOp:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Remove No Op from the Stmt."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`RewriteUnsafeSelect <tvm.tir.transform.RewriteUnsafeSelect>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.RewriteUnsafeSelect:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Detect and rewrite unsafe select that contains memory access."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`Simplify <tvm.tir.transform.Simplify>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.Simplify:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Run arithmetic simplifications on the statements and expressions."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`SkipAssert <tvm.tir.transform.SkipAssert>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.SkipAssert:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Skip assert stmt."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`SplitHostDevice <tvm.tir.transform.SplitHostDevice>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.SplitHostDevice:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Split the function into a host function and device functions."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`StorageFlatten <tvm.tir.transform.StorageFlatten>`\\ "
"\\(cache\\_line\\_size\\[\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.transform.transform.StorageFlatten:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Flatten the multi-dimensional read/write to 1D."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`StorageRewrite <tvm.tir.transform.StorageRewrite>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.StorageRewrite:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Rewrite storage allocation pattern."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`TextureFlatten <tvm.tir.transform.TextureFlatten>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.TextureFlatten:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Flatten the multi-dimensional read/write to 2D."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`ThreadSync <tvm.tir.transform.ThreadSync>`\\ "
"\\(storage\\_scope\\)"
msgstr ""

#: of tvm.tir.transform.transform.ThreadSync:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Insert sync between parallel read/write of shared buffers."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`UnifyThreadBinding <tvm.tir.transform.UnifyThreadBinding>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
"Unify all the thread bindings for \"blockIdx.x/y/z\", "
"\"threadIdx.x/y/z\", and \"vthread.x/y/z\"."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`UnrollLoop <tvm.tir.transform.UnrollLoop>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.transform.UnrollLoop:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Unroll the constant loop marked by unroll."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ""
":py:obj:`VectorizeLoop <tvm.tir.transform.VectorizeLoop>`\\ "
"\\(\\[enable\\_vectorize\\]\\)"
msgstr ""

#: of tvm.tir.transform.transform.VectorizeLoop:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Lower vectorization loops."
msgstr ""

#: of tvm.tir.transform:1:<autosummary>:1
msgid ":py:obj:`VerifyMemory <tvm.tir.transform.VerifyMemory>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.verify_memory:1
#: tvm.tir.stmt.Block:1:<autosummary>:1
#: tvm.tir.transform.transform.VerifyMemory:1
#: tvm.tir.transform:1:<autosummary>:1
msgid "Verify if func contains illegal host side direct memory access."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:1:<autosummary>:1
msgid ":py:obj:`PrimFuncPass <tvm.tir.transform.PrimFuncPass>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:1:<autosummary>:1
msgid "A pass that works on each :py:func:`tvm.tir.PrimFunc` in a module."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:3
msgid ""
"This function returns a callback when pass_func is provided. Otherwise, "
"it returns the created function pass using the given optimization "
"function."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:7
msgid "The transformation function or class."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:9
msgid "The optimization level of this module pass."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:11
msgid ""
"The name of the function pass. The name could be empty. In this case, the"
" name of the optimization function will be used as the pass name."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:14
msgid "The list of passes that the function pass is dependent on."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:17
msgid ""
"**create_function_pass** -- A decorator will be returned if pass_func is "
"not provided, otherwise return the decorated result. The returned "
"decorator has two behaviors depending on the input: A new FunctionPass "
"will be returned when we decorate a pass function. A new FunctionPass "
"class will be returned when we decorate a class type."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:26
msgid "The following code block decorates a function pass class."
msgstr ""

#: of tvm.tir.transform.function_pass.prim_func_pass:40
msgid ""
"The following code creates a function pass by decorating a user defined "
"transform function."
msgstr ""

#: of tvm.tir.transform.function_pass.PrimFuncPass:1
msgid ""
"A pass that works on each :py:func:`tvm.tir.PrimFunc` in a module. A "
"function pass class should be created through "
"py:func:`tvm.tir.transform.function_pass`."
msgstr ""

#: of tvm.tir.transform.transform.Apply:3
msgid "This function is a thin wrapper around tvm.tir.transform.prim_func_pass"
msgstr ""

#: of tvm.tir.transform.transform.Apply:5
msgid "The transformation pass."
msgstr ""

#: of tvm.tir.transform.transform.Apply:8
#: tvm.tir.transform.transform.BF16CastElimination:11
#: tvm.tir.transform.transform.BF16Legalize:4
#: tvm.tir.transform.transform.BF16Promote:4
#: tvm.tir.transform.transform.BF16TypeLowering:4
#: tvm.tir.transform.transform.CoProcSync:3
#: tvm.tir.transform.transform.CombineContextCall:3
#: tvm.tir.transform.transform.CompactBufferAllocation:35
#: tvm.tir.transform.transform.ConvertBlocksToOpaque:5
#: tvm.tir.transform.transform.ConvertForLoopsToSerial:3
#: tvm.tir.transform.transform.DecorateDeviceScope:3
#: tvm.tir.transform.transform.Filter:6
#: tvm.tir.transform.transform.FlattenBuffer:5
#: tvm.tir.transform.transform.HoistIfThenElse:16
#: tvm.tir.transform.transform.InferFragment:3
#: tvm.tir.transform.transform.InjectCopyIntrin:8
#: tvm.tir.transform.transform.InjectDoubleBuffer:3
#: tvm.tir.transform.transform.InjectPrefetch:3
#: tvm.tir.transform.transform.InjectVirtualThread:3
#: tvm.tir.transform.transform.InstrumentBoundCheckers:3
#: tvm.tir.transform.transform.LegalizePackedCalls:3
#: tvm.tir.transform.transform.LiftAttrScope:6
#: tvm.tir.transform.transform.LoopPartition:3
#: tvm.tir.transform.transform.LowerCustomDatatypes:5
#: tvm.tir.transform.transform.LowerDeviceStorageAccessInfo:3
#: tvm.tir.transform.transform.LowerInitBlock:3
#: tvm.tir.transform.transform.LowerIntrin:3
#: tvm.tir.transform.transform.LowerMatchBuffer:3
#: tvm.tir.transform.transform.LowerTVMBuiltin:3
#: tvm.tir.transform.transform.LowerThreadAllreduce:3
#: tvm.tir.transform.transform.LowerWarpMemory:3
#: tvm.tir.transform.transform.MakePackedAPI:8
#: tvm.tir.transform.transform.MakeUnpackedAPI:3
#: tvm.tir.transform.transform.MergeDynamicSharedMemoryAllocations:4
#: tvm.tir.transform.transform.NarrowDataType:6
#: tvm.tir.transform.transform.PlanAndUpdateBufferAllocationLocation:5
#: tvm.tir.transform.transform.RemoveNoOp:3
#: tvm.tir.transform.transform.RewriteUnsafeSelect:3
#: tvm.tir.transform.transform.Simplify:3
#: tvm.tir.transform.transform.SkipAssert:3
#: tvm.tir.transform.transform.SplitHostDevice:3
#: tvm.tir.transform.transform.StorageFlatten:8
#: tvm.tir.transform.transform.StorageRewrite:7
#: tvm.tir.transform.transform.TextureFlatten:5
#: tvm.tir.transform.transform.ThreadSync:6
#: tvm.tir.transform.transform.UnifyThreadBinding:8
#: tvm.tir.transform.transform.UnrollLoop:5
#: tvm.tir.transform.transform.VectorizeLoop:7
#: tvm.tir.transform.transform.VerifyMemory:3
msgid "**fpass** -- The result pass"
msgstr ""

#: of tvm.tir.transform.transform.BF16CastElimination:1
msgid ""
"Eliminate verbose casting between fp32 and bf16 Checks if the AST has the"
" pattern: castto32(castto16(some_fp32_op(...))) The verbose casting is "
"generated by BF16Promote for multiple bf16 Ops in a row. e.g.: X[i] + "
"Y[i] + T[i] => bf16((float32(bf16((float32(X[i]) + float32(Y[i])))) + "
"float32(T[i]))) After this pass: bf16(float32(X[i]) + float32(Y[i]) + "
"float32(T[i]))"
msgstr ""

#: of tvm.tir.transform.transform.BF16Legalize:1
msgid ""
"Legalize bf16 typed Ops. Runs BF16Promote, BF16CastElimination and "
"BF16TypeLowering"
msgstr ""

#: of tvm.tir.transform.transform.BF16Promote:1
msgid ""
"Promote bf16 to fp32. Add a cast to fp32 before Ops, then add a cast back"
" to bf16."
msgstr ""

#: of tvm.tir.transform.transform.BF16TypeLowering:1
msgid ""
"Replace all bf16 type with uint16. Also lower the casting between fp32 "
"and bf16"
msgstr ""

#: of tvm.tir.transform.transform.CompactBufferAllocation:1
msgid ""
"Compact the buffer access region. by removing the buffer regions that are"
" not accessed, i.e. narrowing the buffer shape and adjust the access "
"region if necessary."
msgstr ""

#: of tvm.tir.transform.transform.CompactBufferAllocation:7
msgid ""
"Before narrowing, ``B`` is a ``[16, 16]`` buffer, but only a skinny "
"vector ``B[i, 0:16]`` is accessed."
msgstr ""

#: of tvm.tir.transform.transform.CompactBufferAllocation:20
msgid ""
"This pass narrows the buffer shape and adjust its accessed region "
"accordingly.  In this particular case, because only a ``1 * 16`` vector "
"of ``B`` is accessed, the pass narrows ``B`` to shape ``[1, 16]``, and "
"changes the access to ``B[i, j]`` to ``B[0, j]``."
msgstr ""

#: of tvm.tir.transform.transform.Filter:3
msgid "The condition of the filtering."
msgstr ""

#: of tvm.tir.transform.transform.FlattenBuffer:1
msgid ""
"Flatten the multi-dimensional BufferLoad and BufferStore to single "
"dimensional Load/Store. Also remove Block to ensure that the flattened "
"TIR can not be scheduled again."
msgstr ""

#: of tvm.tir.transform.transform.HoistIfThenElse:3
msgid ""
"The variant of the pass. variant can have any one of following values "
"[\"basic\", None(Default)].  The basic variant supports basic hoisting "
"scenarios where it expects the For & If Nodes are in place consecutively "
"and does not involve global scope variables or more advanced scenarios.  "
"Default variant supports all hoisting scenarios,i.e., {\"Basic\" + "
"\"Advanced\"} supported with control with PassContext configs like below:"
"      config={\"tir.HoistIfThenElse\": {\"support_block_scope_hosting\": "
"True}}"
msgstr ""

#: of tvm.tir.transform.transform.HoistIfThenElse:3
msgid ""
"The variant of the pass. variant can have any one of following values "
"[\"basic\", None(Default)]."
msgstr ""

#: of tvm.tir.transform.transform.HoistIfThenElse:6
msgid ""
"The basic variant supports basic hoisting scenarios where it expects the "
"For & If Nodes are in place consecutively and does not involve global "
"scope variables or more advanced scenarios."
msgstr ""

#: of tvm.tir.transform.transform.HoistIfThenElse:10
msgid ""
"Default variant supports all hoisting scenarios,i.e., {\"Basic\" + "
"\"Advanced\"} supported with control with PassContext configs like below:"
msgstr ""

#: of tvm.tir.transform.transform.HoistIfThenElse:13
msgid "config={\"tir.HoistIfThenElse\": {\"support_block_scope_hosting\": True}}"
msgstr ""

#: of tvm.tir.transform.transform.InjectCopyIntrin:3
msgid "The pragma key for hint of copy."
msgstr ""

#: of tvm.tir.transform.transform.InjectCopyIntrin:5
msgid ""
"The function with signature copyintrin(src, dst, pad_before, pad_after, "
"pad_value)"
msgstr ""

#: of tvm.tir.transform.transform.LiftAttrScope:3
msgid "The attribute key to be checked."
msgstr ""

#: of tvm.tir.transform.transform.LowerCustomDatatypes:3
msgid ""
"See tvm::datatypes::Registry for more information on adding custom "
"datatypes."
msgstr ""

#: of tvm.tir.transform.transform.LowerDeviceStorageAccessInfo:6
msgid "Run this pass after all storage access analysis finish."
msgstr ""

#: of tvm.tir.transform.transform.LowerMatchBuffer:1
msgid "Remove match buffers inside the block. Also, it will validate the binding."
msgstr ""

#: of tvm.tir.transform.transform.MakePackedAPI:3
msgid ""
"Number of parameters that we hope to directly pass via normal arguments "
"following the PackedFunc input signature. If it is specified as -1 or it "
"is less than the number of arguments, the pass will packed arguments "
"still."
msgstr ""

#: of tvm.tir.transform.transform.NarrowDataType:3
msgid "The target bit configuration."
msgstr ""

#: of tvm.tir.transform.transform.NarrowDataType:9
msgid "Run this pass after StorageFlatten."
msgstr ""

#: of tvm.tir.transform.transform.PlanAndUpdateBufferAllocationLocation:1
msgid ""
"Locate the buffer allocation to the exact position (usually is the lca of"
" buffer access). This pass will inject opaque block with alloc_buffers at"
" the allocation site."
msgstr ""

#: of tvm.tir.transform.transform.StorageFlatten:4
msgid "The size of CPU cache line."
msgstr ""

#: of tvm.tir.transform.transform.StorageFlatten:6
msgid "Whether to create bound attributes."
msgstr ""

#: of tvm.tir.transform.transform.StorageRewrite:3
msgid ""
"Moves the allocation to outer most possible scope. Trying to share space "
"between allocations to make a static allocation plan when possible."
msgstr ""

#: of tvm.tir.transform.transform.UnifyThreadBinding:1
msgid ""
"Unify all the thread bindings for \"blockIdx.x/y/z\", "
"\"threadIdx.x/y/z\", and \"vthread.x/y/z\". Before the unification, two "
"vars that are bound to a thread axis (e.g., \"threadIdx.x\") use "
"different IterVars and variables in their AttrStmts. After the "
"unification, we use a consolidated IterVar and a variable for them."
msgstr ""

#: of tvm.tir.transform.transform.UnifyThreadBinding:13
msgid ""
"`vthread` is a legacy behavior that will be deprecated, though thread "
"bindings of `vthread` are still also unified in this pass. Please use "
"`vthread.x`, `vthread.y` and `vthread.z` instead."
msgstr ""

#: of tvm.tir.transform.transform.UnrollLoop:3
msgid ""
"This pass also automatically attach pragma unroll tag to loops which "
"meets the standard."
msgstr ""

#: of tvm.tir.transform.transform.VectorizeLoop:3
msgid ""
"Whether vectorization is enabled. Will lower to scalar loop when it is "
"turned off."
msgstr ""

#: ../../_staging/reference/api/python/tir.rst:38
msgid "tvm.tir.analysis"
msgstr ""

#: of tvm.tir.analysis:1
msgid "Namespace of all TIR analysis utils."
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1
msgid ""
":py:obj:`Block <tvm.tir.analysis.Block>`\\ \\(iter\\_vars\\, reads\\, "
"writes\\, name\\_hint\\, body\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1
msgid ":py:obj:`Buffer <tvm.tir.analysis.Buffer>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1
msgid ""
":py:obj:`BufferRegion <tvm.tir.analysis.BufferRegion>`\\ \\(buffer\\, "
"region\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1
msgid ":py:obj:`PrimExpr <tvm.tir.analysis.PrimExpr>`\\ \\(\\)"
msgstr ""

#: of tvm.ir.expr.PrimExpr:1 tvm.tir.analysis:1:<autosummary>:1
msgid "Base class of all primitive expressions."
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1
msgid ""
":py:obj:`PrimFunc <tvm.tir.analysis.PrimFunc>`\\ \\(params\\, body\\[\\, "
"ret\\_type\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1
msgid ":py:obj:`Stmt <tvm.tir.analysis.Stmt>`\\ \\(\\)"
msgstr ""

#: of tvm.tir.analysis:1:<autosummary>:1
msgid ":py:obj:`Var <tvm.tir.analysis.Var>`\\ \\(name\\, dtype\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
":py:obj:`calculate_workspace_bytes "
"<tvm.tir.analysis.calculate_workspace_bytes>`\\ \\(func\\, ...\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.calculate_workspace_bytes:1
#: tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
"Calculate the workspace size in bytes needed by the TIR allocates inside "
"the TIR PrimFunc."
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
":py:obj:`detect_buffer_access_lca "
"<tvm.tir.analysis.detect_buffer_access_lca>`\\ \\(func\\)"
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
"Detect the lowest common ancestor(LCA) of buffer access, including both "
"high-level access(BufferLoad, BufferStore) and low-level access(Load, "
"Store and opaque access)."
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
":py:obj:`expr_deep_equal <tvm.tir.analysis.expr_deep_equal>`\\ \\(lhs\\, "
"rhs\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:1
#: tvm.tir.stmt.Block:1:<autosummary>:1
msgid "Deeply compare two nested expressions."
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
":py:obj:`get_block_access_region "
"<tvm.tir.analysis.get_block_access_region>`\\ \\(block\\, "
"buffer\\_var\\_map\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:2
#: tvm.tir.stmt.Block:1:<autosummary>:1
msgid "Detect which regions of tensors in this block are read or written to."
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
":py:obj:`get_block_read_write_region "
"<tvm.tir.analysis.get_block_read_write_region>`\\ \\(block\\, ...\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_read_write_region:2
#: tvm.tir.stmt.Block:1:<autosummary>:1
msgid "Auto detect the block read/write region according to its body stmt."
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ""
":py:obj:`verify_gpu_code <tvm.tir.analysis.verify_gpu_code>`\\ \\(func\\,"
" constraints\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.verify_gpu_code:1
#: tvm.tir.stmt.Block:1:<autosummary>:1
msgid "Verify if module contains illegal host side direct memory access."
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ":py:obj:`verify_memory <tvm.tir.analysis.verify_memory>`\\ \\(func\\)"
msgstr ""

#: of tvm.tir.stmt.Block:1:<autosummary>:1
msgid ":py:obj:`verify_ssa <tvm.tir.analysis.verify_ssa>`\\ \\(func\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.verify_ssa:1
#: tvm.tir.stmt.Block:1:<autosummary>:1
msgid "Verify if the func is in SSA form."
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ""
":py:obj:`access_ptr <tvm.tir.analysis.Buffer.access_ptr>`\\ "
"\\(access\\_mask\\[\\, ptr\\_type\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ""
":py:obj:`vload <tvm.tir.analysis.Buffer.vload>`\\ \\(begin\\[\\, "
"dtype\\]\\)"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ":py:obj:`vstore <tvm.tir.analysis.Buffer.vstore>`\\ \\(begin\\, value\\)"
msgstr ""

#: of tvm.tir.buffer.Buffer.access_ptr:1:<autosummary>:1
msgid ":py:obj:`scope <tvm.tir.analysis.Buffer.scope>`\\ \\(\\)"
msgstr ""

#: of tvm.ir.expr.PrimExpr:3
msgid "PrimExpr is used in the low-level code optimizations and integer analysis."
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid ""
":py:obj:`with_body <tvm.tir.analysis.PrimFunc.with_body>`\\ "
"\\(new\\_body\\[\\, span\\]\\)"
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid ""
":py:obj:`specialize <tvm.tir.analysis.PrimFunc.specialize>`\\ "
"\\(param\\_map\\)"
msgstr ""

#: of tvm.tir.function.PrimFunc.with_body:1:<autosummary>:1
msgid ""
":py:obj:`script <tvm.tir.analysis.PrimFunc.script>`\\ "
"\\(\\[tir\\_prefix\\, show\\_meta\\]\\)"
msgstr ""

#: of tvm.tir.analysis.analysis.calculate_workspace_bytes:4
#: tvm.tir.analysis.analysis.detect_buffer_access_lca:5
msgid "The function to be detected."
msgstr ""

#: of tvm.tir.analysis.analysis.calculate_workspace_bytes:6
msgid "The byte alignment required for each tensor"
msgstr ""

#: of tvm.tir.analysis.analysis.calculate_workspace_bytes:9
msgid "**result** -- Workspace size in bytes."
msgstr ""

#: of tvm.tir.analysis.analysis.detect_buffer_access_lca:1
msgid ""
"Detect the lowest common ancestor(LCA) of buffer access, including both "
"high-level access(BufferLoad, BufferStore) and low-level access(Load, "
"Store and opaque access). The LCA may be a For loop or a Block."
msgstr ""

#: of tvm.tir.analysis.analysis.detect_buffer_access_lca:8
msgid "**result** -- Map from buffer to the LCA of all access to it."
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:3
msgid "The left operand."
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:5
msgid "The right operand."
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:8
msgid "**result** -- The comparison result"
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:13
msgid ""
"This function does not remap variable bindings, it will not return true "
"for (let x = 1 in x + 1) vs (let y = 1 in y + 1), unless x.same_as(y). "
"Use py:func:`tvm.ir.structural_equal` to handle structural variable "
"remapping."
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:17
msgid ""
"Due to the restriction of not remapping variables, this function can run "
"faster than StructuralEqual and can be used as a utility function during "
"arithmetic simplifications."
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:21
msgid ""
"Always consider py:func:`tvm.ir.structural_equal` first, which handles "
"the structural remapping."
msgstr ""

#: of tvm.tir.analysis.analysis.expr_deep_equal:24
msgid ":obj:`tvm.ir.structural_equal`"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:2
msgid "Regions are sorted by order of appearance in the AST."
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:4
#: tvm.tir.analysis.analysis.get_block_read_write_region:4
msgid "The block in which we are detecting read/write regions."
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:6
#: tvm.tir.analysis.analysis.get_block_read_write_region:6
msgid ""
"The outside buffers which may access the block. Mapping from buffer var "
"to the buffer"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:9
msgid ""
"**result** --  Array of access regions. There are three arrays of "
"BufferRegion:     - first: read regions     - second: write regions     -"
" third: opaque regions"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:9
msgid "**result** --"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:13
msgid "Array of access regions. There are three arrays of BufferRegion:"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:12
msgid "first: read regions"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:13
msgid "second: write regions"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_access_region:14
msgid "third: opaque regions"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_read_write_region:2
msgid "An opaque access will be counted as both a read and a write access"
msgstr ""

#: of tvm.tir.analysis.analysis.get_block_read_write_region:9
msgid ""
"**result** -- An array only consisting of the read regions and write "
"regions of the input block"
msgstr ""

#: of tvm.tir.analysis.analysis.verify_gpu_code:3
#: tvm.tir.analysis.analysis.verify_memory:3
#: tvm.tir.analysis.analysis.verify_ssa:3
msgid "The module to be verified."
msgstr ""

#: of tvm.tir.analysis.analysis.verify_gpu_code:5
msgid "The attribute constraints."
msgstr ""

#: of tvm.tir.analysis.analysis.verify_gpu_code:8
#: tvm.tir.analysis.analysis.verify_memory:6
#: tvm.tir.analysis.analysis.verify_ssa:6
msgid "**result** -- The result of verification."
msgstr ""

#: ../../_staging/reference/api/python/tir.rst:47
msgid "tvm.tir.stmt_functor"
msgstr ""

#: of tvm.tir.stmt_functor:1
msgid "Statement functor utilities for IR transformations"
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:1:<autosummary>:1
msgid ""
":py:obj:`ir_transform <tvm.tir.stmt_functor.ir_transform>`\\ \\(stmt\\, "
"preorder\\, postorder\\[\\, ...\\]\\)"
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:1
#: tvm.tir.stmt_functor.ir_transform:1:<autosummary>:1
msgid "Recursively visit and transform ir nodes in post DFS order."
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:1:<autosummary>:1
msgid ""
":py:obj:`post_order_visit <tvm.tir.stmt_functor.post_order_visit>`\\ "
"\\(stmt\\, fvisit\\)"
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:1:<autosummary>:1
#: tvm.tir.stmt_functor.post_order_visit:2
msgid "Recursively visit the ir in post DFS order node, apply fvisit"
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:1:<autosummary>:1
msgid ""
":py:obj:`substitute <tvm.tir.stmt_functor.substitute>`\\ \\(node\\, "
"vmap\\)"
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:1:<autosummary>:1
#: tvm.tir.stmt_functor.substitute:1
msgid "Substitute the var specified by vmap."
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:3
msgid "The input to be transformed."
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:5
msgid ""
"The function called in before recursive mutation If preorder returns "
"None, then the transform will proceed to recursive call. If preorder "
"returns a not None tvm.tir.Stmt/Expr, the transformer will simply return "
"it and won't do further recursion."
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:10
msgid "The function called after recursive mutation."
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:12
msgid "List of types that we only enable."
msgstr ""

#: of tvm.tir.stmt_functor.ir_transform:15 tvm.tir.stmt_functor.substitute:8
msgid "**result** -- The result."
msgstr ""

#: of tvm.tir.stmt_functor.post_order_visit:2
msgid "Each node is guaranteed to be visited only once."
msgstr ""

#: of tvm.tir.stmt_functor.post_order_visit:4
msgid "The visitor function."
msgstr ""

#: of tvm.tir.stmt_functor.substitute:3
msgid "The input."
msgstr ""

#: of tvm.tir.stmt_functor.substitute:5
msgid "The variable mapping."
msgstr ""

