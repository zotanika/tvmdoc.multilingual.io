# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.dev0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-01-04 20:34+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../dev/pass_infra.rst:21
msgid "Pass Infrastructure"
msgstr "패스 인프라스트럭쳐"

#: ../../dev/pass_infra.rst:23
msgid ""
"Both Relay and TVM IR contain a series of optimization passes which "
"improve performance metrics of models such as mean inference, memory "
"footprint, or power consumption for specific devices. There is a suite of"
" standard optimizations as well as machine learning-specific "
"optimizations including constant folding, dead code elimination, operator"
" layout alteration, operator fusion, buffer handling, and loop "
"transformation, etc. Each of these passes is structured as a ir-to-ir "
"transformation using the analysis result collected during and/or before "
"traversal."
msgstr ""
"Relay와 TVM IR 모두 평균 추론 속도, 메모리 사용량, 특정 장치에서의 소모 전력 등, "
"모델의 성능 메트릭을 향상시키는 일련의 최적화 패스를 포함합니다. "
"상수 폴딩, 죽은 코드 제거, 연산자 레이아웃 변경, 연산자 융합, 버퍼 핸들링, 루프 변형 등으로 "
"구성된 머신러닝 특화 최적화와 표준 최적화가 모두 함께 제공됩니다. 이들 패스 각각은 구조적으로 "
"그래프 순회 전후에 수집된 분석 결과를 활용한 IR-IR' 변형의 형태를 띱니다. "

#: ../../dev/pass_infra.rst:31
msgid ""
"However, as TVM evolves quickly, the need for a more systematic and "
"efficient way to manage these passes is becoming apparent. In addition, a"
" generic framework that manages the passes across different layers of the"
" TVM stack (e.g. Relay and tir) paves the way for developers to quickly "
"prototype and plug the implemented passes into the system."
msgstr ""
"그러나 TVM이 빠르게 진화할수록, 이들 패스들을 보다 체계적이고 효과적으로 관리할 필요성이 "
"점차 뚜렷해지고 있습니다. 이에 더해, TVM 스택 (e.g. Relay와 tir)의 서로 다른 계층을 가로지르는 "
"패스들을 관리하는 범용 프레임워크는 개발자들로 하여금 새롭게 구현된 패스를 빠르게 프로토타이핑하고 "
"시스템에 삽입할 수 있도록 길을 터줍니다. "

#: ../../dev/pass_infra.rst:37
msgid ""
"This doc describes the design of such an infra that takes the advantage "
"of the way production compilers are used to manage the optimization "
"passes and the style modern deep learning frameworks adopted to build up "
"layers."
msgstr ""
"이 문서는, 최적화 패스를 관리하기 위해 프로덕션 컴파일러가 활용되는 방식과 신경망 레이어를 "
"쌓기 위해 현대적인 딥러닝 프레임워크가 채택되는 스타일의 이점을 취한 인프라의 디자인에 대해 서술합니다. "

#: ../../dev/pass_infra.rst:41
msgid ""
"For example, many existing production compilers, such as GCC and LLVM, "
"employ pass managers to effectively manage the execution of passes. "
"Initially managing passes is straightforward as the number of passes is "
"small, but mature compilers will contain hundreds of individual passes. "
"Often external users will want to have custom passes correctly scheduled "
"without having to modify a single handcrafted pass order."
msgstr ""
"예를 들어, 기존의 많은 프로덕션 컴파일러들, GCC나 LLVM 등은 실행 패스를 효과적으로 "
"관리하기 위해 패스 매니저를 채용합니다. "
"초기의 패스 관리는 패스 개수가 적기 때문에 꽤나 직관적입니다. 하지만 성숙한 컴파일러는 수백개의 "
"개별 패스들을 보유하게 됩니다. 게다가 외부 사용자들도 수작업된 패스 순서를 손대지 않고서도 "
"자신의 커스텀 패스가 정확하게 스케줄되길 원하게 되죠. "

#: ../../dev/pass_infra.rst:48
msgid ""
"Similarly, modern deep learning frameworks, such as Pytorch and MXNet "
"Gluon, also have the tendency to enable pass-style layer construction "
"scheme through `Sequential`_ and `Block`_, respectively. With such "
"constructs, these modern frameworks are able to conveniently add "
"modules/layers to their containers and build up neural networks easily."
msgstr ""
"이와 유사하게, Pytorch과 MXNet/Gluon 등과 같은 현대적인 딥러닝 프레임워크들도 "
"각각 `Sequential`_ 과 `Block`_ 를 통해 레이어를 구축하는 패스 스타일의 스킴이 "
"활용되는 추세입니다. "
"이로 인해 현대적인 프레임워크들이 편리하게 모듈/레이어들을 그들의 컨테이너에 편리하게 추가하고 "
"신경망을 쉽게 구축할 수 있습니다. "

#: ../../dev/pass_infra.rst:54
msgid ""
"The design of the Relay pass infra is largely inspired by the the "
"hierarchical pass manager used in LLVM and the block-style containers "
"used in the popular deep learning frameworks. The major goals of the pass"
" infra include:"
msgstr ""
"Relay 패스 인프라의 디자인은 LLVM에 쓰이는 계층적 패스 매니저와 주요 딥러닝 프레임워크들이 사용하는 "
"블록 스타일 컨테이너에 아주 큰 영향을 받았습니다. "
"이 패스 인프라의 주요 목표는:"

#: ../../dev/pass_infra.rst:58
msgid ""
"enabling better programmatic orchestration of optimizations. This allows "
"users to flexibly customize and build their own optimization pipelines."
msgstr ""
"최적화 작업의 더 나은 프로그램적 조화. 이로써 사용자들로 하여금 각자의 최적화 파이프라인을 "
"만들고 융통성있게 커스텀할 수 있게 합니다."

#: ../../dev/pass_infra.rst:61
msgid "providing a user-friendly way to debug optimization passes."
msgstr "사용자 친화적인 최적화 패스 디버깅 방법을 제공하기."

#: ../../dev/pass_infra.rst:63
msgid ""
"alleviating developers from manually and respectively resolving the "
"dependencies between passes."
msgstr ""
"패스들 사이의 의존성을 개발자들이 직접 일일이 풀어야 하는 부담을 경감시키기."

#: ../../dev/pass_infra.rst:66
msgid ""
"simplifying the implementation of new passes for developers. For example,"
" we allow users to implement a pass in Python and let the pass infra "
"manipulate its execution."
msgstr ""
"개발자들을 위해 새로운 패스 구현을 단순화하기. 예컨대, 사용자로 하여금 파이썬으로 패스를 "
"구현할 수 있게끔 하고 패스 인프라를 통해 실행을 제어할 수 있게끔 합니다."

#: ../../dev/pass_infra.rst:71
msgid "The Design"
msgstr "디자인"

#: ../../dev/pass_infra.rst:73
msgid ""
"We focus on ease of extension for users, making it possible for users to "
"quickly add new passes without loss of backward compatibility. The design"
" contains both the backend and the frontend. The former implements the "
"main logic of the pass infra. The latter provides simple APIs for users "
"to interact with, i.e., allowing users to quickly create their own "
"optimization pipelines."
msgstr ""
"우리는 사용자들이 하위 호환성 유실에 대한 우려 없이 새로운 패스를 빠르게 추가할 수 있도록 하여 "
"손쉽게 기능을 확장할 수 있도록 하는 데에 집중합니다. "
"디자인은 백엔드와 프론트엔드 양 측 모두를 아우릅니다. 전자의 경우는 패스 인프라의 주요 동작 구현과 "
"관련되고, 후자의 경우는 사용자들로 하여금 그들만의 최적화 파이프라인을 빠르게 생성할 수 있도록, "
"사용자들이 상호작용할 간단한 API들의 정의와 관련됩니다. "

#: ../../dev/pass_infra.rst:80
msgid "C++ Backend"
msgstr "C++ 백엔드"

#: ../../dev/pass_infra.rst:82
msgid ""
"We provide a ``PassInfo`` object to contain the basic information needed "
"by a pass. ``name`` is the pass name, ``opt_level`` indicates at which "
"optimization level the pass will be enabled, and ``required`` represents "
"the passes that are required to execute a certain pass (see "
"`include/tvm/ir/transform.h`_ for more details). For example, during "
"registration of a pass (will be covered in later), the pass developers "
"can specify the name of the pass, the optimization level it will be "
"performed at, and/or the passes that are required. ``opt_level`` could be"
" used to help the pass infra identify if a certain pass needs to be "
"executed when running under a user-provided optimization level. The "
"``required`` field can be used by the pass infra to resolve pass "
"dependencies."
msgstr ""
"``PassInfo`` 는 패스가 필요로 하는 기본적인 정보를 담는 객체입니다. "
"``name`` 은 패스 명칭이고, ``opt_level`` 은 어느 정도의 최적화 레벨로 패스를 활성화할 것인지를 "
"가리키며, ``required`` 는 어떤 특정 패스의 실행에 요구되는 패스들을 나타냅니다(더 자세한 사항은 "
"`include/tvm/ir/transform.h`_ 를 참고). "
"예컨대 패스 등록 과정에서(나중에 다룸), 패스 개발자는 패스의 명칭, 어느 최적화 레벨에서 작동할 것인지, "
"그리고/또는 필요로 하는 패스들까지 지정할 수 있습니다. "
"``opt_level`` 은, 사용자에 의해 최적화 레벨이 주어지는 경우, 패스 인프라가 어떤 패스를 작동시켜야 하는지 "
"구분할 수 있도록 돕는 데에 사용될 수도 있습니다. "
"``required`` 필드는 패스 인프라가 패스 간의 의존성 해소를 위해 사용합니다. "

#: ../../dev/pass_infra.rst:102 ../../dev/pass_infra.rst:403
msgid "PassContext"
msgstr "PassContext"

#: ../../dev/pass_infra.rst:104
msgid ""
"``PassContext`` carries useful information for an optimization pass. For "
"example, it contains the error reporting system so optimization authors "
"can provide diagnostics about why an optimization fails. ``PassContext`` "
"is also designed to replace the old ``BuildConfig`` which was used to "
"help users configure the compilation options, including optimization "
"level and required/disabled passes, etc. For instance, we may have a "
"configuration which performs all passes at ``opt_level=3`` with some "
"disabled passes using ``disabled_pass=xx`` provided by ``PassContext``. "
"Now we could glob all passes at ``opt_level=3`` and exclude those in the "
"disabled pass list."
msgstr ""
"``PassContext`` 는 최적화 패스를 위한 유용한 정보들을 담고 있습니다. 예를 들어, 여기에 포함된 "
"오류 보고 시스템은 왜 최적화가 실패하는지에 대해 패스 작성자가 진단할 수 있게끔 합니다. "
"``PassContext`` 는 예전에 사용자들이 최적화 레벨이나 활성화/비활성화 패스 지정과 같은 컴파일 옵션을 "
"설정하는 데에 사용되던 ``BuildConfig`` 를 대체하기 위해 디자인된 측면도 있습니다. "
"예컨대, ``PassContext`` 에 제공되는 ``disabled_pass=xx`` 를 써서 몇몇 패스들을 비활성화한 "
"채로 ``opt_level=3`` 에서 모든 패스들을 동작시키도록 설정하고자 할 수 있습니다. "
"이제 ``opt_level=3`` 인 모든 패스들을 걸러낸 다음 이들을 비활성 패스 리스트에서 배제할 수도 있습니다. "

#: ../../dev/pass_infra.rst:114
msgid ""
"This class is designed for users to conveniently write the Python "
"``with`` syntax to perform optimizations under a certain configuration. "
"In addition, the users can obtain the context that is available within a "
"certain program scope in a thread-safe way through "
"``PassContext::Current()``, since a thread-local store "
"``PassContextThreadLocalStore`` is used to hold the created pass context "
"objects. Examples will be provided later to show how we can use both the "
"C++ and Python APIs to create a compilation pipeline using pass context."
msgstr ""
"이 클래스는 특정한 조건 하에서 최적화를 수행할 수 있도록 ``with`` 문법으로 편리하게 파이썬 코드를 "
"작성할 수 있게 디자인되었습니다. "
"게다가 사용자는 ``PassContext::Current()`` 를 통해 멀티쓰레딩 환경에서도 동시성 문제 없이 "
"특정 프로그램의 변수영역(scope) 내에서 가용한 컨텍스트를 얻을 수 있는데, 생성된 패스 컨텍스트 객체를 담는 데에 "
"국지적 쓰레드 저장(TLS) 기능인 ``PassContextThreadLocalStore`` 이 사용되기 때문입니다. "
"패스 컨텍스트를 활용한 컴파일 파이프라인을 생성하기 위해 C++과 파이썬 API를 사용하는 방법을 보여주는 "
"예제가 아래 제공될 것입니다. "

#: ../../dev/pass_infra.rst:163
msgid "Pass Constructs"
msgstr "패스 구축"

#: ../../dev/pass_infra.rst:165
msgid ""
"The pass infra is designed in a hierarchical manner, and it could work at"
" different granularities of Relay/tir programs. A pure virtual class "
"``PassNode`` is introduced to serve as the base of the different "
"optimization passes. This class contains several virtual methods that "
"must be implemented by the subclasses at the level of modules, functions,"
" or sequences of passes."
msgstr ""
"패스 인프라는 계층적으로 디자인되었으며, Relay/tir 프로그램들의 세분화 정도(granularity)에 "
"맞춰 다르게 작동할 수 있습니다. 순수한 가상 클래스인 ``PassNode`` 는 서로 다른 최적화 패스들의 "
"베이스 역할을 하도록 고안되었습니다. 이 클래스는 모듈, 함수, 또는 패스 적용 순서의 각 수준에 따라 "
"서브클래스에 의해 구현되어야 하는 몇 가지 가상 메서드들을 포함합니다. "

#: ../../dev/pass_infra.rst:179
msgid ""
"The functor shows how a pass must be realized, i.e. it always works on a "
":py:class:`IRModule` under a certain context. All passes are designed in "
"a ``Module`` to ``Module`` manner. Therefore, optimizations governed by "
"the pass infra will always update the whole module."
msgstr ""
"함자(functor)는 패스가 어떻게 실체화되어야 하는지 보여줍니다. 즉, 패스는 언제나 특정 컨텍스트 "
"하에서 :py:class:`IRModule` 에 작용합니다. "
"모든 패스는 ``Module`` 이 ``Module`` 에 대응하는 형식으로 디자인됩니다. 따라서, 패스 인프라에 의해 "
"관리되는 최적화는 항상 전체 모듈을 갱신하게 되어 있습니다. "

#: ../../dev/pass_infra.rst:184
msgid ""
"Several subclasses have been created to implement different types of "
"optimization passes, e.g., function-level passes, module-level passes, "
"and sequential passes.  Each subclass itself could act as a pass manager."
" For instance, they could collect the required passes and execute them or"
" build a dependency graph based on the given metadata. The full "
"definition of them can be found in `src/relay/ir/transform.cc`_ and "
"`src/ir/transform.cc`_."
msgstr ""
"몇몇 서브클래스들은, 각기 다른 형태의 최적화 패스들, 가령 함수 수준 패스, 모듈 수준 패스, 그리고 "
"순차적 패스 등의 구현을 위해 생성되었습니다. 각 서브클래스 자체는 패스 매니저처럼 동작할 수도 있습니다. "
"예컨대 필요한 패스 목록을 수집하고, 이를 실행하거나 주어진 메타데이터에 기반해 의존성 그래프를 구축해 내기도 합니다. "
"`src/relay/ir/transform.cc`_ 와 `src/ir/transform.cc`_ 에서 정확한 정의를 찾아볼 수 있습니다. "

#: ../../dev/pass_infra.rst:192
msgid "Module-Level Passes"
msgstr "모듈 수준 패스"

#: ../../dev/pass_infra.rst:194
msgid ""
"Module level passes are geared mainly for global and inter-procedural "
"optimizations (IPO), which are similar to the module pass used in LLVM. "
"Some typical passes in Relay that need the global picture of a module, "
"such as A-normal form conversion and lambda lifting, etc., fall into this"
" set. At this level, users can even add and/or delete functions in a "
"module. Note that all passes"
msgstr ""
"모듈 수준 패스들은 주로 프로시져간 최적화(IPO: inter-procedural optimizations)와 같은 "
"전반적인 최적화에 적합하며, 이는 LLVM에서의 모듈 패스의 역할과 유사합니다. "
"A-일반형태(ANF: A-normal form) 전환이나 람다 리프팅 등과 같이 모듈의 전체적인 상을 필요로 하는 "
"Relay의 몇몇 전형적인 패스들이 이 부류에 속합니다. "
"이 수준의 패스에서는, 모듈에서 함수를 새로 추가하거나 삭제하는 것조차도 가능합니다. "

#: ../../dev/pass_infra.rst:210
msgid ""
"``pass_info`` maintains the information needed by a module-level pass. "
"``pass_func`` sketches the real optimization. For example, we may need to"
" perform dead code elimination on the module. We could implement the "
"algorithm in the ``pass_func`` and let it run on a module. It will then "
"remove the dead code including the unused functions in the module. Note "
"that this field is designed as a packed function, which enables the "
"implementation of the optimization in both C++ and Python."
msgstr ""
"모듈 수준 패스가 필요로 하는 정보들은 ``pass_info`` 가 보유합니다. "
"``pass_func`` 는 실제 최적화를 스케치합니다. 가령 어떤 모듈에서 죽은 코드 제거를 수행할 필요가 있을 때, "
"``pass_func`` 안에 알고리즘을 구현하고 모듈 상에서 실행할 수 있습니다. "
"이는 곧 모듈 내에서 사용되지 않는 함수들을 포함한 죽은 코드들을 제거하게 될 것입니다. "
"이 필드는, C++ 및 파이썬으로 최적화 구현이 가능한 포장함수로서 디자인된다는 점에 유념하세요. "

#: ../../dev/pass_infra.rst:219
msgid "Function-Level Passes"
msgstr "함수 수준 패스"

#: ../../dev/pass_infra.rst:221
msgid ""
"Function-level passes are used to implement various intra-function level "
"optimizations for a given Relay/tir module. It fetches one function at a "
"time from the function list of a module for optimization and yields a "
"rewritten Relay ``Function`` or tir ``PrimFunc``. Most of passes can be "
"classified into this category, such as common subexpression elimination "
"and inference simplification in Relay as well as vectorization and "
"flattening storage in tir, etc."
msgstr ""
"함수 수준 패스는 주어진 Relay/tir 모듈에 대해 다양한 함수 자체적 수준의 최적화를 구현하는 데에 "
"활용됩니다. "
"이는 최적화를 위해 모듈의 함수 리스트로부터 한 번에 하나의 함수를 가져와, 재작성된 Relay ``Function`` "
"나 tir ``PrimFunc`` 를 내놓습니다. 대부분의 패스들, 하위표현식 제거나 Relay에서의 추론 간략화, "
"tir의 벡터화 및 저장소 평탄화 등이 이 카테고리로 분류될 수 있습니다. "

#: ../../dev/pass_infra.rst:228
msgid ""
"Note that the scope of passes at this level is either a Relay function or"
" a tir primitive function. Therefore, we cannot add or delete a function "
"through these passes as they are not aware of the global information."
msgstr ""
"이 수준의 패스들이 다루는 범위는 Relay 함수나 tir 원시 함수라는 점에 유의하세요. "
"따라서, 우리는 포괄적인 정보를 인지하지 못하는 이들 패스를 통해 함수를 추가하거나 삭제할 수 없습니다. "

#: ../../dev/pass_infra.rst:242
msgid ""
"``pass_info`` is identical to what we just described in the module pass. "
"``pass_func`` takes a function for optimization, it also needs a module "
"as we may use it for reporting errors. A function could be annotated with"
" \"SkipOptimization\" so that it will be ignored during optimization."
msgstr ""
"``pass_info`` 는 모듈 패스 섹션에서 서술한 것과 동일합니다. "
"``pass_func`` 는 최적화를 위해 함수를 취하며, 오류 보고를 위해 활용할 모듈도 필요로 합니다. "
"어떤 함수에 \"SkipOptimization\" 로 주석 처리를 하면, 그 함수에 대한 최적화 처리를 무시할 수 있습니다. "

#: ../../dev/pass_infra.rst:248
msgid "Sequential Passes"
msgstr "순차적 패스"

#: ../../dev/pass_infra.rst:250
msgid ""
"``SequentialPass`` is similar to Pytorch ``nn.Sequential`` that contains "
"a host of passes for execution."
msgstr ""
"``SequentialPass`` 는 파이토치에서 패스 실행을 관장하는 ``nn.Sequential`` 과 유사합니다. "

#: ../../dev/pass_infra.rst:263
msgid ""
"Only a few passes currently in Relay are put in this group. For example, "
"``FoldScaleAxis`` requires to dispatch ``ForwardFoldScaleAxis`` and "
"``BackwardFoldScaleAxis`` internally. In addition, "
"``BackwardFoldScaleAxis`` is recommended to be fulfilled first. This "
"pass, hence, is an ideal candidate for ``SequentialPass``."
msgstr ""
"현재 Relay에서는 소수의 패스만이 이 부류에 속합니다. ``ForwardFoldScaleAxis`` 과 "
"``BackwardFoldScaleAxis`` 를 내부적으로 디스패치해야만 하는 ``FoldScaleAxis`` 이 그러한 예입니다. "
"추가적으로 ``BackwardFoldScaleAxis`` 을 먼저 수행하는 것이 바람직합니다. 이런 의미에서 이 패스는 "
"``SequentialPass`` 의 이상적인 후보라고 할 수 있겠지요. "

#: ../../dev/pass_infra.rst:269
msgid ""
"The following code shows how individual passes in a sequential pass are "
"invoked. Essentially, we sequentially execute each pass in a sequential "
"pass using the order that they were appended to the pass list."
msgstr ""
"이어지는 코드는 순차적 패스 군집 내의 각 패스가 어떻게 호출되는지를 보여줍니다. "
"원칙적으로, 우리는 순차적 패스 내의 각 패스들을 패스 리스트에 덧붙여진 순서대로 차례로 실행합니다. "

#: ../../dev/pass_infra.rst:292
msgid ""
"Upon the invocation of a pass, we first check if this pass is enabled. "
"This is done by first checking if the pass is explicitly disabled by a "
"user, followed by inspecting if it is specified as a required pass by the"
" user. If it is still undetermined whether this pass is enabled, its "
"``opt_level`` will be checked. This pass will be enabled and therefore "
"executed only when its optimization level is not less than the configured"
" optimization level in the pass context."
msgstr ""
"패스의 호출에 있어, 먼저 이 패스가 활성화되어 있는지를 확인하게 됩니다. "
"이 작업은, 사용자에 의해 해당 패스가 명시적으로 불활성화되어 있는지, 이어서 사용자가 필요로 하는 패스로 "
"규정되어 있는지의 여부를 검사함으로써 수행됩니다. "
"그럼에도 여전히 패스의 활성화 여부를 결정할 수 없다면, ``opt_level`` 을 확인합니다. "
"이 최적화 레벨이 패스 컨텍스트에 설정된 최적화 레벨 이상일 경우에만 해당 패스가 활성화되고 실행 가능하게 됩니다. "

#: ../../dev/pass_infra.rst:299
msgid ""
"To execute the pass, we need first to retrieve the registered pass in the"
" TVM packed function registry using the pass name. This is possible "
"because every pass is registered with an API endpoint as we will show "
"later."
msgstr ""
"패스를 실행하기 위해서, 먼저 패스 명칭을 사용해 TVM 포장함수 레지스트리 내에 등록된 패스를 검색할 필요가 있습니다. "
"이는, 후술될 내용과 같이, 모든 패스가 API 엔드포인트로 직결되어 있기에 가능합니다. "

#: ../../dev/pass_infra.rst:314
msgid ""
"Some helper functions are provided to create each type of these "
"aforementioned passes. These helpers are also exposed to the Python "
"frontend for users to favorably use Python APIs to create a specific pass"
" object."
msgstr ""
"앞서 설명된 각 유형의 패스들을 생성하기 위해 제공되는 도우미 함수들이 있습니다. 이들은 파이썬 프론트엔드에 "
"노출되어, 사용자들이 특정 패스 객체를 생성하기 위한 파이썬 API를 손쉽게 활용하게끔 합니다. "

#: ../../dev/pass_infra.rst:341
msgid "Pass Registration"
msgstr "패스 등록"

#: ../../dev/pass_infra.rst:343
msgid ""
"We've covered the concept of different level of passes and the context "
"used for compilation. It would be interesting to see how easily users can"
" register a pass.  Let's take const folding as an example. This pass has "
"already been implemented to fold constants in a Relay function (found in "
"`src/relay/pass/fold_constant.cc`_)."
msgstr ""
"지금까지 다양한 수준의 패스들에 대한 개념과 컴파일레이션에 활용되는 컨텍스트에 대해 다뤄 봤습니다. "
"사용자들이 얼마나 쉽게 패스를 등록할 수 있는지 살펴 보는 것도 흥미로울 것입니다. "
"상수 폴딩을 예로 들어 봅시다. 이 패스는 Relay 함수 내의 상수들을 집적(fold)할 수 있도록 "
"이미 구현되어 있는 상태입니다(`src/relay/pass/fold_constant.cc`_ 을 참고하세요). "

#: ../../dev/pass_infra.rst:349
msgid "An API was provided to perform the ``Expr`` to ``Expr`` transformation."
msgstr "``Expr`` 대 ``Expr`` 변환을 수행하기 위해 API 하나가 제시되었습니다. "

#: ../../dev/pass_infra.rst:355
msgid ""
"In order to register this pass to the pass infra, we first need to decide"
" at which level this pass will be performed. As const folding happens on "
"individual functions, we should intuitively create a ``FunctionPass`` for"
" it through ``CreateFunctionPass``. The ``pass_func`` is returned as a "
"packed function that invokes the ``Expr`` to ``Expr`` API on each "
"function in a `IRModule`. ``{}`` indicates that no prerequisite is "
"required for this pass. Otherwise, the pass developer has to identify and"
" list them."
msgstr ""
"이 패스를 패스 인프라에 등록하기 위해서, 먼저 이 패스가 어느 최적화 레벨에서 작동하게 할지 결정해야 합니다. "
"상수 폴딩은 개별 함수 단위에서 수행되는만큼, ``CreateFunctionPass`` 를 통해 ``FunctionPass`` 를 생성해야 함을 직관적으로 알 수 있습니다. "
"``pass_func`` 은 `IRModule` 내의 각 함수마다 ``Expr`` 대 ``Expr`` API를 불러오는 포장함수로서 반환됩니다. "
"``{}`` 은 이 패스가 아무런 전제 조건을 필요로 하지 않는다는 것을 보여주며, 그렇지 않다면 패스 개발자는 "
"여기에 필요 조건을 확정하여 나열해야 합니다. "

#: ../../dev/pass_infra.rst:363
msgid ""
"Meanwhile, a pass API endpoint is registered with the name "
"``relay._transform.FoldConstant``. This pass, therefore, becomes an entry"
" in the registry that can be accessed by both C++ (e.g. the ``GetPass`` "
"above) and Python when needed."
msgstr ""
"한편, 패스 API 엔드포인트는 ``relay._transform.FoldConstant`` 이라는 명칭으로 등록됩니다. "
"그에 따라 이 패스는 필요하다면 C++(e.g. ``GetPass`` 이상)과 파이썬 모두에서 접근 가능한 레지스트리의 항목이 됩니다. "

#: ../../dev/pass_infra.rst:385
msgid ""
"To allow other C++ modules to apply this pass, we declare a free function"
" in `include/tvm/relay/transform.h`_ as the following:"
msgstr ""
"다른 C++ 모듈들이 이 패스를 적용할 수 있도록 허용하기 위해, 다음과 같이 `include/tvm/relay/transform.h`_ 에 단독함수(free function)를 선언해 두었습니다. "

#: ../../dev/pass_infra.rst:393
msgid "Python Frontend"
msgstr "파이썬 프론트엔드"

#: ../../dev/pass_infra.rst:395
msgid ""
"Only some simple APIs are needed for the frontend side. For example, we "
"can provide users the following APIs to create and execute a pass (full "
"implementation is provided in `python/tvm/relay/transform.py`_ and "
"`python/tvm/ir/transform.py`_). The backend receives the information and "
"decides which function it should use to create a Pass object."
msgstr ""
"프론트엔드 측은 몇가지의 간단한 API로 집약됩니다. 예컨대, 패스의 생성과 실행을 위한 API들을 "
"다음과 같이 제공합니다(전체 구현은 `python/tvm/relay/transform.py`_ 와 `python/tvm/ir/transform.py`_ 를 참조). "
"백엔드는 정보를 수집하고 Pass 객체를 생성하려면 어떤 함수를 써야할지 결정합니다. "

#: ../../dev/pass_infra.rst:405
msgid ""
"Python frontend provides a wrapper for the ``PassContext`` to enable the "
"``with`` syntax by overriding ``__enter__`` and ``__exit__``. A "
"``current`` static method is offered for users to get the context that is"
" in use under a certain scope."
msgstr ""
"파이썬 프론트엔드는 ``__enter__`` 와 ``__exit__`` 를 오버라이딩하여 ``with`` 구문을 지원할 수 있도록 "
"``PassContext`` 를 포장합니다. ``current`` 정적 메서드는 사용자들이 특정한 변수영역 하에서 사용되고 있는 "
"컨텍스트를 확인할 수 있도록 하기 위해 제공됩니다. "

#: ../../dev/pass_infra.rst:426
msgid ""
"A ``PassContext`` is used to configure the compilation options, including"
" the optimization level and required/disabled passes. It can also take a "
"dictionary of configs so that different passes can conveniently fetch the"
" passed data, such as fallback device info and step/depth for loop "
"unrolling, etc. In order to enable fetching the required config, the key "
"must be registered through ``TVM_REGISTER_PASS_CONFIG_OPTION``. For "
"example, the following is used by the loop unrolling pass"
msgstr ""
"``PassContext`` 는 최적화 수준과 활성화/비활성화 패스 등을 포함하는 컴파일레이션 옵션들을 "
"설정하기 위해 사용됩니다. 또한, 여러 설정들로 이루어진 딕셔너리를 취하여, 예비(fallback) 장치 정보나 루프 "
"풀어헤치기(loop unrolling)의 단계/깊이 등과 같이, 주어진 정보들에 알맞게 서로 다른 패스들을 조달할 수 있도록 합니다. "
"필요로 하는 설정이 패치될 수 있도록 만드려면, ``TVM_REGISTER_PASS_CONFIG_OPTION`` 을 통해 "
"키를 등록해야 합니다. 다음은 루프 풀어헤치기 패스에서 사용되는 예시입니다.

#: ../../dev/pass_infra.rst:438
msgid "Please refer to `src/tir/transforms/unroll_loop.cc`_ for more details."
msgstr "더 자세한 내용은 `src/tir/transforms/unroll_loop.cc`_ 을 참고하세요."

#: ../../dev/pass_infra.rst:441
msgid "Pass Objects"
msgstr "패스 객제"

#: ../../dev/pass_infra.rst:443
msgid ""
"``Pass`` is the base class of all pass objects. All methods here are just"
" simple wrappers that were implemented in the backend. They are defined "
"for users to conveniently interact with the base class in Python. Only a "
"``__call__`` is defined in the pass base class to make the subclasses as "
"callable objects so that they can be invoked easily (e.g., "
"``pass_xx(arg)``) for execution."
msgstr ""
"``Pass`` 는 모든 패스 객체의 베이스 클래스입니다. 여기의 모든 메서드들은 단순히 후방(backend)에서 "
"구현되어야 할 것들의 껍데기입니다. 이들은 사용자들이 파이썬으로 베이스 클래스와 편리하게 상호작용할 수 "
"있도록 정의되었습니다. 패스 베이스 클래스에서 오직 ``__call__`` 만이 호출 가능한 객체로서의 서브 클래스를 "
"만들기 위해 정의되어, 간결한 호출로 (e.g., ``pass_xx(인자)``) 실행될 수 있게 합니다. "

#: ../../dev/pass_infra.rst:456
msgid ""
"Some auxiliary APIs are provided to enable easy creation of passes from "
"the Python frontend and to let the pass infra control the execution. For "
"example, ``module_pass``, ``function_pass``, and ``sequential`` are "
"provided to users so that they can customize their own pass or pass "
"pipeline."
msgstr ""
"파이썬 프론트엔드로부터 패스들을 간이 생성하고 패스 인프라로 하여금 실행을 제어할 수 있게끔 만들어 주는 "
"얼마간의 보조 API들도 제공됩니다. 예컨대, ``module_pass``, ``function_pass``, 그리고 ``sequential`` "
"들이 사용자에게 제공되어, 각자의 패스나 패스 파이프라인을 커스터마이징할 수 있게 됩니다. "

#: ../../dev/pass_infra.rst:461
msgid ""
"For all the passes that are implemented in the C++ backend, we provide "
"corresponding Python APIs in `python/tvm/ir/transform.py`_ and "
"`python/tvm/relay/transform.py`_, respectively. For instance, const "
"folding has a Python API like the following:"
msgstr ""
"C++ 백엔드에 구현되어 있는 모든 패스들을 위한 파이썬 API들이 각각 `python/tvm/ir/transform.py`_ 와 "
"`python/tvm/relay/transform.py`_ 에 제공됩니다. 예컨대, 상수 폴딩은 다음과 같은 파이썬 API를 보유합니다: "

#: ../../dev/pass_infra.rst:471
msgid "Users can build a pass through decoration like the following:"
msgstr "사용자는 아래와 같이 파이썬 데코레이션으로 패스를 작성할 수 있습니다:"

#: ../../dev/pass_infra.rst:489
msgid ""
"The ``transform`` function here adds an ``abs`` function to the input "
"module, but it could be any customized optimizations at the module level."
" After creating this ``module_pass``, users can apply it on any Relay "
"module. For example, we can build an empty module and apply this pass to "
"add an ``abs`` function."
msgstr ""
"여기서는 ``transform`` 함수가 입력 모듈에 ``abs`` 함수 하나를 덧붙이는 정도이지만, 모듈 수준에서 "
"어떠한 맞춤형 최적화도 가능합니다. "
"이 ``module_pass`` 를 생성한 후, 사용자들은 어떠한 Relay 모듈에도 이를 적용할 수 있습니다. "
"가령, 빈 모듈을 만들고 이 패스를 적용하면 ``abs`` 함수를 더할 수 있습니다. "

#: ../../dev/pass_infra.rst:500
msgid ""
"Correspondingly, we also offer such functionality for ``function_pass``. "
"For instance, an example function-level pass could be written as the "
"following:"
msgstr ""
"``function_pass`` 에 대해서도 상응하는 기능들이 제공됩니다. "
"예제로서, 다음과 같이 함수 수준 패스를 작성할 수도 있습니다: "

#: ../../dev/pass_infra.rst:524
msgid ""
"Alternatively, users can also directly register a pass without using the "
"decorators and then invoke it. For more examples about how to customize "
"your own optimization pipeline and debug Relay and tir passes, please "
"refer to the `use pass infra`_ tutorial."
msgstr ""
"데코레이터 구문 형식에 따르는 대신, 사용자들은 직접 패스를 등록하고 불러올 수도 있습니다. "
"사용자 고유의 최적화 파이프라인의 커스터마이징과 Relay 및 tir 패스들의 디버깅에 관련된 더 많은 예제들은 "
"`use pass infra`_ 튜토리얼에서 찾아볼 수 있습니다. "

